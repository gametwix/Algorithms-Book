% Моисеенков

\begin{center}
	\includeimage{0.9}{images/40_1.pdf} \\
	\textit{Путь Коня на шахматной доске}
\end{center}

Проще говоря, \textbf{узел} представляет собой любой объект, а \textbf{ребро} представляет отношение между двумя объектами.

\vspace{\baselineskip}

\textbf{Смежный узел:}

\vspace{\baselineskip}

Если узел \textbf{A} и узел \textbf{B} делят между собой ребро, то \textbf{B} считается смежным с \textbf{A}. Другими словами, если два узла напрямую связаны, они называются смежными узлами. Один узел может иметь несколько смежных узлов.

\vspace{\baselineskip}

\textbf{Ориентированный и неориентированный граф:}

\vspace{\baselineskip}

Если в ориентированных графах ребра имеют указатели направления только на одной стороне, то это означает, что ребра \textit{однонаправлены}. Если же ребра неориентированных графов имеют указатели направления с обеих сторон, то это означает, что они \textit{двунаправлены}. Обычно неориентированные графы представлены без каких-либо знаков по обе стороны от ребер.

\vspace{\baselineskip}

Давайте предположим, что у нас идёт вечеринка в самом разгаре. Люди на вечеринке - это узлы, и когда они пожимают друг другу руки, то образуется связь(грань) между двумя людьми. Тогда этот граф является неориентированным, потому что любой человек \textbf{А} пожимает руку человеку \textbf{B} тогда и только тогда, когда \textbf{B} также пожимает руку \textbf{А}. Однако, если ребру между человеком \textbf{А} и \textbf{Б} соответствует такая связь, как восхищение, то граф ориентированный, так как восхищение не обязательно является взаимным. Первый тип графа называется \textit{неориентированным графом}, а его ребра называются \textit{неориентированными ребрами}, а последний тип графа называется \textit{ориентированным графом}, а его ребра - \textit{ориентированными ребрами}.

\vspace{\baselineskip}

\textbf{Взвешенный и невзвешенный граф:}

\vspace{\baselineskip}

Взвешенный граф - это граф, в котором число (вес) присваивается каждому ребру. Такие веса могут обозначать, например, стоимость, длину или производительность, в зависимости от поставленной задачи.

\begin{center}
	\includeimage{0.5}{images/41_1.pdf}
\end{center}

Невзвешенный граф - обратный случай (ребра в нём не имеют веса). Предположим, что вес всех ребер одинаков (например 1).

\vspace{\baselineskip}

\textbf{Путь:}

\vspace{\baselineskip}

Путь представляет собой способ перехода от одного узла к другому. Он состоит из последовательности ребер. Между двумя узлами может быть несколько путей.

\begin{center}
	\includeimage{0.5}{images/41_2.pdf}
\end{center}

В приведенном выше примере есть два пути от \textbf{A} до \textbf{D}. \textbf{A->B, B-> C, C-> D} - это один путь. Стоимость этого пути \textbf{3 + 4 + 2 = 9}. Опять же, есть другой путь \textbf{A->D}. Стоимость этого пути - \textbf{10}. Путь с наименьшей стоимостью называется \textit{кратчайшим}.

\vspace{\baselineskip}

\textbf{Степень:}

\vspace{\baselineskip}

Степень вершины - это число ребер, которые связаны с ней. Если есть ребро, которое соединяется с вершиной на обоих концах (цикл), то оно считается два раза.

\vspace{\baselineskip}

В ориентированных графах узлы имеют два типа степеней:
\begin{itemize}
    \item Входящая степень: количество ребер, которые указывают на узел.
    \item Исходящая степень: количество ребер, которые, исходя из данного узла, указывают на другие
\end{itemize}

Для неориентированного графа, они просто называются степенью.

\begin{center}
    \includeimage{0.4}{images/42_1.pdf}
\end{center}

\textbf{Некоторые алгоритмы, связанные с теорией графов:}
\begin{itemize}
    \item Алгоритм Беллмана – Форда
    \item Алгоритм Дейкстры
    \item Алгоритм Форда – Фулкерсона
    \item Алгоритм Крускала
    \item Алгоритм ближайшего соседа
    \item Алгоритм Прима
    \item Поиск в глубину
    \item Поиск в ширину
\end{itemize}

\section*{Раздел 9.3: Хранение графов (Список смежности)}

\href{https://en.wikipedia.org/wiki/Adjacency_list}{\underline{Список смежности}} представляет собой набор неупорядоченных списков, используемых для представления конечного графа. Каждый список описывает набор соседних вершин в графе. Для хранения графов используется меньше пямяти.

\vspace{\baselineskip}

Давайте посмотрим на граф и его матрицу смежности:

\includeimage{0.4}{images/42_2.pdf}
\includeimage{0.5}{images/42_3.pdf}

Теперь мы создадим список, используя эти значения.

\includeimage{0.6}{images/43_1.pdf}

Это называется списком смежности. Он показывает взаимосвязь между узлами графа. Мы можем хранить эту информацию, используя двумерный массив. Но это будет стоить нам столько же памяти, сколько стоит матрица смежности. Вместо этого мы будем динамически выделять память для её хранения.

\vspace{\baselineskip}

Многие языки программирования поддерживают \textbf{векторы (Vector)} или \textbf{списки (List)}, которые мы можем использовать для хранения списка смежности. Для этого нам не нужно указывать размер \textbf{списка}. Нам нужно только указать максимальное количество узлов.

\vspace{\baselineskip}

Соответствующий псевдокод будет таким:

\begin{tcolorbox}
\begin{minted}{C}
Procedure Adjacency-List(maxN, E):
edge[maxN] = Vector()
for i from 1 to E
	input -> x, y
	edge[x].push(y)
	edge[y].push(x)
end for
Return edge
\end{minted}
\end{tcolorbox}

Так как это неориентированный граф, то если есть ребро от \textbf{x} до \textbf{y}, то соответственно есть и ребро от \textbf{y} до \textbf{x}. Если бы это был ориентированный граф, мы бы опустили второе условие. Для взвешенных графов нам также нужно хранить стоимость (вес). Мы создадим \textbf{вектор} или \textbf{список} с именем \textbf{cost []} для её хранения. Псевдокод:

\begin{tcolorbox}
\begin{minted}{C}
Procedure Adjacency-List(maxN, E):
edge[maxN] = Vector()
cost[maxN] = Vector()
for i from 1 to E
	input -> x, y, w
	edge[x].push(y)
	cost[x].push(w)
end for
Return edge, cost
\end{minted}
\end{tcolorbox}

Из этого мы можем легко узнать общее количество связанных узлов, а также что это именно за узлы. \\
Это занимает меньше времени, чем Матрица Смежности. Но если бы нам нужно было выяснить, есть ли грань между \textbf{u} и \textbf{v}, то было бы проще, если бы мы сохранили матрицу смежности.

\section*{Раздел 9.4: Топологическая сортировка}

Топологическое упорядочение или топологическая сортировка упорядочивает вершины в ориентированном ациклическом графе в линию (то есть в список) так, чтобы все направленные ребра шли слева направо. Такое упорядочение не может существовать, если граф содержит направленный цикл, потому что нет такого способа, которым вы можете продолжать идти прямо по линии и вернуться туда, откуда вы начали.

\vspace{\baselineskip}

Формально в графе $G = (V, E)$ линейное упорядочение всех его вершин
таково, что если G содержит ребро $(u, v) \in E$ из вершины $u$ в вершину $v$, то $u$ предшествует $v$ в упорядочении.

\vspace{\baselineskip}

Важно отметить, что каждый направленный ациклический граф (DAG) имеет \textit{по крайней мере один} топологический вид.

\vspace{\baselineskip}

Известны алгоритмы для построения топологического упорядочения любого DAG за линейное время, одним из примеров является:

\begin{enumerate}
    \item Вызовите {\usefont{T2A}{cmtt}{m}{n} depth\_first\_search (G)} для вычисления времени окончания {\usefont{T2A}{cmtt}{m}{n} v.f} для каждой вершины {\usefont{T2A}{cmtt}{m}{n} v}
    \item По завершении каждой вершины, вставьте её в начало связанного списка
    \item Получаем отсортированный связанный список вершин.
\end{enumerate}

Топологическая сортировка может быть выполнена за О(V + E), поскольку алгоритм поиска в глубину занимает О(V + E) времени и требуется $\Omega$ (\textcolor{Purple}{1}) (постоянное время) для вставки каждой из |V| вершины в начале связанного списка.

\vspace{\baselineskip}

Многие приложения используют ориентированные ациклические графы для указания приоритетов среди событий. Мы используем топологическую сортировку, чтобы получить порядок обработки каждой вершины перед любым из ее наследников.

\vspace{\baselineskip}

Вершины в графе могут представлять задачи, которые должны быть выполнены, а ребра могут представлять ограничения, в соответствии с которыми одна задача должна быть выполнена перед другой; топологическое упорядочение является допустимой последовательностью для выполнения задач, набор которых описан в V.

\vspace{\baselineskip}

\textbf{Пример проблемы и ее решение}

\vspace{\baselineskip}

Пусть вершина {\usefont{T2A}{cmtt}{m}{n} v} описывает задачу {\usefont{T2A}{cmtt}{m}{n}  Task(hours\_to\_complete: \textcolor{Blue}{int})}, т.е. {\usefont{T2A}{cmtt}{m}{n} Task(\textcolor{Purple}{4}} описывает задачу, выполнение которой занимает 4 часа, а грань {\usefont{T2A}{cmtt}{m}{n} e} описывает время отката {\usefont{T2A}{cmtt}{m}{n} Cooldown(hours: \textcolor{Blue}{int})}, так что {\usefont{T2A}{cmtt}{m}{n} Cooldown(\textcolor{Purple}{3})} описывает время следующего отката после выполненной задачи.

\vspace{\baselineskip}

Пусть наш граф называется dag (так как это ориентированный ациклический граф), и пусть он содержит 5 вершин:

\begin{tcolorbox}
    {\usefont{T2A}{cmtt}{m}{n}
    A \textcolor{Gray}{<--}dag.\textcolor{Blue}{add\_vertex}(Task(\textcolor{Purple}{4})); \\
    B \textcolor{Gray}{<--}dag.\textcolor{Blue}{add\_vertex}(Task(\textcolor{Purple}{5})); \\
    C \textcolor{Gray}{<--}dag.\textcolor{Blue}{add\_vertex}(Task(\textcolor{Purple}{3})); \\
    D \textcolor{Gray}{<--}dag.\textcolor{Blue}{add\_vertex}(Task(\textcolor{Purple}{2})); \\
    E \textcolor{Gray}{<--}dag.\textcolor{Blue}{add\_vertex}(Task(\textcolor{Purple}{7}));}
\end{tcolorbox}

где мы соединяем вершины с направленными ребрами так, чтобы граф был ациклическим,

\begin{tcolorbox}
{\usefont{T2A}{cmtt}{m}{n} 
\textcolor{Green}
{// A -----> C ----------+ \\
// |\hspace{1.3cm}|\hspace{1.3cm}| \\
// v\hspace{1.3cm}v\hspace{1.3cm}v \\
// B -----> D -----> E} \\
dag.\textcolor{Blue}{add\_edge}(A, B, Cooldown(\textcolor{Purple}{2})); \\
dag.\textcolor{Blue}{add\_edge}(A, C, Cooldown(\textcolor{Purple}{2})); \\
dag.\textcolor{Blue}{add\_edge}(B, D, Cooldown(\textcolor{Purple}{1})); \\
dag.\textcolor{Blue}{add\_edge}(C, D, Cooldown(\textcolor{Purple}{1})); \\
dag.\textcolor{Blue}{add\_edge}(C, E, Cooldown(\textcolor{Purple}{1})); \\
dag.\textcolor{Blue}{add\_edge}(D, E, Cooldown(\textcolor{Purple}{3}));
}\end{tcolorbox}

и следовательно, мы имеем 3 возможных топологических упорядочивания между А и Е,

\begin{enumerate}
    \item A --> B --> D --> E
    \item A --> C --> D --> E
    \item A --> C --> E
\end{enumerate}

\section*{Раздел 9.5. Обнаружение цикла в ориентированном графе}

Цикл в ориентированном графе существует, если во время DFS обнаружено заднее ребро. Заднее ребро - это грань, идущая от узла к себе или к одному из предков в дереве DFS. Для неориентированного графа мы получаем лес DFS, поэтому нужно перебрать все вершины графа, чтобы найти несвязанные деревья DFS.

\vspace{\baselineskip}

Реализация на C ++:

\begin{tcolorbox}
\begin{minted}{C++}
#include <iostream>
#include <list>

using namespace std;

#define NUM_V 4

bool helper(list<int> *graph, int u, bool* visited, bool* recStack)
{
	visited[u]=true;
	recStack[u]=true;
	list<int>::iterator i;
	for(i = graph[u].begin();i!=graph[u].end();++i)
	{
		if(recStack[*i])
			return true;
		else if(*i==u)
			return true;
		else if(!visited[*i])
		{ 
			if(helper(graph, *i, visited, recStack))
			return true;
		}
	}
	recStack[u]=false;
	return false;
}

bool isCyclic(list<int> *graph, int V)
{
	bool visited[V];
	bool recStack[V];
	
	for(int i = 0;i<V;i++)
		visited[i]=false, recStack[i]=false;
	for(int u = 0; u < V; u++) 
	{ 
		if(visited[u]==false)
		{ 
			if(helper(graph, u, visited, recStack))
			return true;
		}
	}
	return false;
}

int main()
{
	list<int>* graph = new list<int>[NUM_V];
	graph[0].push_back(1);
	graph[0].push_back(2);
	graph[1].push_back(2);
	graph[2].push_back(0);
	graph[2].push_back(3);
	graph[3].push_back(3);
	bool res = isCyclic(graph, NUM_V);
	cout<<res<<endl;
}
\end{minted}
\end{tcolorbox}

Результат: как показано ниже, на графе есть три задних ребра. Один между вершиной 0 и 2; между вершинами 0, 1 и 2; и вершина 3. Временная сложность поиска составляет O (V + E), где V - количество вершин, а E - количество ребер.

\includeimage{0.5}{images/46_1.pdf}

\section*{Раздел 9.6: Алгоритм Торупа}

Алгоритм Торупа для кратчайшего пути с одним источником для неориентированного графа имеет временную сложность O(m), меньшую, чем у Дейкстры.

\vspace{\baselineskip}

Основные идеи следующие. (Извините, я еще не пытался это реализовать, поэтому могу пропустить некоторые мелкие детали. А оригинал документа платный, так что я попытался восстановить его из других источников, ссылающихся на него. Пожалуйста, удалите этот комментарий, если вы можете проверить.)

\begin{itemize}
    \item Есть способы найти связующее дерево за время O(m) (здесь это не описано). Вам нужно «вырастить» остовное дерево от самого короткого ребра до самого длинного, и это будет лес с несколькими связными компонентами до полного выращивания.
    \item Выберите целое число b ($b \geq 2$) и рассмотрите только остовные леса с ограничением длины $b^k$. Объедините компоненты, которые абсолютно одинаковы, но с разными k, и назовите минимальным k уровнем компоненту. Затем логически превратите компоненты в дерево. u является родителем v, если u является наименьшой компонентой, отличной от v, которая полностью содержит v. Корень - это весь граф, а листья - это отдельные вершины в исходном графе (с уровнем отрицательной бесконечности). Дерево все еще имеет только O(n) узлов.
    \item Сохраняйте расстояние от каждой компоненты до источника (как в алгоритме Дейкстры). Расстояние компоненты с несколькими вершинами - это минимальное расстояние ее нерасширенных дочерних элементов. Установите расстояние от исходной вершины на 0 и обновите предков соответственно.
    \item Рассмотрим расстояния в базе b. При первом посещении узла уровня k поместите его дочерние элементы в сегменты, совместно используемые всеми узлами уровня k (как при сортировке сегментов, заменяя путаницу в алгоритме Дейкстры) цифрой k и выше ее расстояния. Каждый раз, посещая узел, учитывайте только его первые b сегментов, посещайте и удаляйте каждый из них, обновляйте расстояние текущего узла и связывайте текущий узел со своим родителем, используя новое расстояние, и ждите следующего посещения для следующего ведра (корзины).
    \item Когда лист посещается, текущее расстояние является конечным расстоянием вершины. Увеличьте все ребра из него в исходном графе и обновите расстояния соответственно.
    \item Посетите корневой узел (всего графа) несколько раз, пока не будет достигнут пункт назначения.
\end{itemize}

Это основано на том факте, что между двумя соединенными компонентами остовного леса с ограничением длины l нет ребра с длиной меньше l, поэтому, начиная с расстояния x, вы можете сосредоточиться только на одной подключенной компоненте, пока не достигнете расстояния х + l. Вы посетите некоторые вершины до того, как все вершины с более коротким расстоянием будут посещены, но это не имеет значения, потому что известно, что из этих вершин не будет более короткого пути сюда. Другие части работают так же, как корзинная сортировка / поразрядная сортировка MSD, и, конечно, для этого требуется связующее дерево O(m).