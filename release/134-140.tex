\chapter*{Глава 24:Многопоточные алгоритмы}

Примеры некоторых многопоточных алгоритмов.

\section*{Раздел 24.1:Многопоточное умножение квадратной матрицы}

\begin{tcolorbox}
\begin{minted}{python}
multiply-square-matrix-parallel(A, B) 
#функция умножения двух квадратных матриц
#переменная хранящая количество линий в матрице А
n = A.lines
#создаем матрицу размера n*n
C = Matrix(n,n) 
#создаем n*n параллельных циклов, каждый из который выполняет по одной итерации
parallel for i = 1 to n
	parallel for j = 1 to n
		#обнуляем элимент матрицы
		C[i][j] = 0
		#проходим k от 1 до n
		pour k = 1 to n
		#прибавляя произведение k-го элемента i строк матрицы A и k-го элемента 
		#j столбца матрицы B
			C[i][j] = C[i][j] + A[i][k]*B[k][j]
#возвращаем матрицу С
return C
\end{minted}
\end{tcolorbox}

\section*{Раздел 24.2:Многопоточное умножение вектора матрицы}

\begin{tcolorbox}
\begin{minted}{python}
matrix-vector(A,x)
	#создаем переменную количества строк матрицы
	n = A.lines
	y = Vector(n) #создаем вектор длины n
	#запускаем параллельно n итераций цикла
	parallel for i = 1 to n
		#обнуляем все элементы вектора
		y[i] = 0
	#запускаем параллельно n итераций цикла
	parallel for i = 1 to n
		#в каждом из них запускаем цикл от 1 до n проходящий по строке i
		for j = 1 to n
			#в каждой итерации прибавляем к элементу  вектора y произведение 
			#элемента i строки,  j столбца и j элемента вектора x
			y[i] = y[i] + A[i][j]*x[j]
#возвращаем вектор y
return y
\end{minted}
\end{tcolorbox}

\section*{Раздел 24.3:Многопоточная сортировка слиянием}

A -- это массив, а p и q -- индексы массива, например, если вы собираетесь отсортировать подмассив A[p..r], то B - это подмассив, который будет заполнен сортировкой.

\vspace{\baselineskip}

Вызов p-merge-sort(A, p, r, B, s) сортирует элементы из A [p..r] и помещает их в B [s..s + r-p].

\begin{tcolorbox}
\begin{minted}{python}
p-merge-sort(A,p,r,B,s)
#многопоточная сортировка подмассива
	#находим длину подмассива
	n = r-p+1
	#если длина равна 1, то не сортируя помещаем элемент массива A в 
	#массив B На позицию s
	if n==1
		B[s] = A[p]
	else
		#создаем массив T длины n
		T = new Array(n) 
		#находим середину отрезка массива, округляя до целого числа
		q = floor((p+r)/2))
		#находим длину половины отрезка
		q_prime = q-p+1
		#запускаем параллельно сортировку двух половин массива, 
		#помещая результат в массив T
		spawn p-merge-sort(A,p,q,T,1)
		p-merge-sort(A,q+1,r,T,q_prime+1)
		sync
		#соединяем две отсортированные половины массива
		p-merge(T,1,q_prime,q_prime+1,n,B,s)
\end{minted}
\end{tcolorbox}

Вот вспомогательная функция, которая выполняет слияние параллельно. P-merge предполагает, что два подмассива для слияния находятся в одном массиве, но не предполагает, что они смежны в массиве. Вот почему нам нужны p1, r1, p2, r2.

\begin{tcolorbox}
\begin{minted}{python}
p-merge(T,p1,r1,p2,r2,A,p3)
	#длина первого отрезка
	n1 = r1-p1+1
	#длина второго отрезка
	n2 = r2-p2+1

	if n1<n2
		#меняем местами надала отрезков
		permute p1 and p2
		#меняем местами концы отрезков
		permute r1 and r2
		#меняем местами длины отрезка
		permute n1 and n2
	if n1==0
		#массив пуст? тогда пусты оба массива
		return
	else
		#округленная середина первого отрезка
		q1 = floor((p1+r1)/2)
		#ищем положение элемента с таким же значением во втором цикле
		q2 = dichotomic-search(T[q1],T,p2,r2)
		#положение элемента в конечном массиве
		q3 = p3 + (q1-p1) + (q2-p2)
		#помещаем элемент в результирующий массив 
		A[q3] = T[q1]
		#параллельно вызываем функции слияния, для левых и 
		#правых половин отрезков массива
		spawn p-merge(T,p1,q1-1,p2,q2-1,A,p3)
		p-merge(T,q1+1,r1,q2,r2,A,q3+1)
		sync
\end{minted}
\end{tcolorbox}

А вот вспомогательная функция дихотомического поиска.

\vspace{\baselineskip}

x - это ключ для поиска в подмассиве T[p..r].

\begin{tcolorbox}
\begin{minted}{python}
dichotomic-search(x,T,p,r)
	#позиция наименьшего элемента массива
	inf = p
	#позиция наименьшего элемента массива
	sup = max(p,r+1)
	#пока позиция наименьшего элемента меньше позиции наибольшего
	while inf<sup
		#находим середину отрезка между наименьшим и наибольшим элементом
		half = floor((inf+sup)/2)
		#если ключ поиска меньше или равен значению середины отрезка 
		if x<=T[half] 
			#приравниваем супремум положению среднего лимента
			sup = half
		else
			#иначе, приравниваем инфимум положению среднего элемента
			inf = half+1
	return sup
\end{minted}
\end{tcolorbox}

\chapter*{Глава 25:Алгоритм Кнута-Морриса-Пратта (KMP)}

KMP -- это алгоритм сопоставления шаблонов, который ищет вхождения "слова" W в главной "текстовой строке" S, используя наблюдение, то есть при возникновении несоответствия у нас есть достаточно информации, чтобы определить, где может начаться следующее совпадение. Мы используем эту информацию, чтобы избежать совпадения с символами, которые, как мы знаем, в любом случае будут совпадать. В худшем случае сложность поиска шаблона уменьшается до O(n).

\section*{Раздел 25.1:Пример KMP}

\textbf{Алгоритм}

\vspace{\baselineskip}

Этот алгоритм состоит из двух этапов. Сначала мы создаем вспомогательный массив lps[], а затем используем его для поиска шаблона.

\vspace{\baselineskip}

\textbf{Предварительная обработка:}
\begin{enumerate}
	\item Мы предварительно обрабатываем шаблон и создаем вспомогательный массив lps[], который используем для пропуска символов при соответствии. 
    \item Здесь lps[] указывает на самый длинный собственный префикс, который также является суффиксом. Собственный префикс - это префикс, в который не включена вся строка. Например, префиксами строки \textbf{ABC} являются «», «\textbf{A}», «\textbf{AB}» и «\textbf{ABC}». Собственными префиксами являются «», «\textbf{A}» и «\textbf{AB}». Суффиксами строки являются «», «\textbf{C}», «\textbf{BC}» и «\textbf{ABC}».
\end{enumerate}

\textbf{Поиск}
\begin{enumerate}
    \item Мы сохраняем совпадающие символы \textbf{txt[i]} и \textbf{pat[j]} и продолжаем увеличивать i и j до тех пор, пока \textbf{pat[j]} и \textbf{txt[i]} совпадают. 
    \item Когда мы видим несоответствие, мы знаем, что символы \textbf{pat[0..j-1]} совпадают с \textbf{txt[i-j+1…i-1]}. Мы также знаем, что \textbf{lps[j-1]} -- это количество символов из \textbf{pat[0…j-1]}, которые являются как собственным префиксом, так и суффиксом. Из этого мы можем сделать вывод, что нам не нужно сопоставлять символы \textbf{lps[j-1]} с \textbf{txt[i-j…i-1]}, потому что мы знаем, что эти символы будут совпадать в любом случае.
\end{enumerate}

\newpage
\textbf{Реализация на Java}

\begin{tcolorbox}
\begin{minted}{java}
public class KMP {

public static void main(String[] args) {
	//строка данный над которой мы будем работать
	String str = "abcabdabc";
	//паттерн, являющийся префиксом и суффиксом
	String pattern = "abc";
	//создаем новый объект класс
	KMP obj = new KMP();
	//выводим строку данных и паттерн
	System.out.println(obj.patternExistKMP(str.toCharArray(),                           pattern.toCharArray()));
}

public int[] computeLPS(char[] str){
	//создаем вспомогательный массив длина которого, равна длины строки
	int lps[] = new int[str.length];
	//обнуляем первый элемент массива и счетчик
	lps[0] = 0;
	int j = 0;
	//обходим всю строку
	for(int i =1;i<str.length;i++){
		//если j элемент строки равен i элементе
		if(str[j] == str[i]){
			//кладем значение j+1 в i элемент вспомогательного массива
			lps[i] = j+1;
			//увеличиваем j и i
			j++;
			i++;
		}else{
			//иначе,если j не равен нулю, то j равен 
			//j-1 элементу вспомогательного массива
			if(j!=0){
				j = lps[j-1];
			}else{
				//если j равен нулю, то приравниваем i 
				//элемент вспомогательного массива значению j+1
				lps[i] = j+1;
				//увеличиваем i
				i++;
			}
		}
	}
	//возвращаем вспомогательный массив 
	return lps;
}

public boolean patternExistKMP(char[] text,char[] pat){
	//заполняем вспомогательный массив
	int[] lps = computeLPS(pat);

	//обнуляем переменные
	int i=0,j=0;
	//пока длина строки больше i и длина паттерна больше j
	while(i<text.length && j<pat.length){
		//если i буква строки равна J букве паттерна
		if(text[i] == pat[j]){
			//увеличивает i и j на единицу
			i++;
			j++;
		}else{
			//иначе,если j не равен нулю, то присваиваем ему значение 
			//элемента j-1 из вспомогательного массива в
			if(j!=0){
				j = lps[j-1];
			}else{
				//иначе увеличиваем i на единицу
				i++;
			}
		}
	}
	//если j равен длине паттерна возвращаем истину, иначе ложь
	if(j==pat.length)
		return true;
	return false;
}

\end{minted}
\end{tcolorbox}

\chapter*{Глава 26:Алгоритм изменения динамического  расстояния}

\section*{Раздел 26.1:Преобразования строки 1 в строку 2}

Постановка задачи выглядит следующим образом: если нам даны две строки str1 и str2, то такое наименьшее количество операций может быть выполнено над str1, чтобы преобразовать ее в str2. Операции могут быть:

\begin{enumerate}
    \item \textbf{Вставить}
    \item \textbf{Удалить}
    \item \textbf{Заменить}
\end{enumerate}

\textbf{Для примера}

\begin{tcolorbox}
Input: str1 = \textcolor{Blue}{"geek"\ }, str2 = \textcolor{Blue}{"gesek"\ }

Output: \p{1}

We only need to insert s in first string

Input: str1 = \textcolor{Blue}{"march"\ }, str2 = \textcolor{Blue}{"cart"\ }

Output: \p{3}

We need to replace m with c and remove character c and then replace h with t
\end{tcolorbox}

Чтобы решить эту проблему, мы будем использовать двумерный массив dp[n+1][m+1], где n -- длина первой строки, а m -- длина второй строки. Для нашего примера, если str1 -- это \textbf{azcef}, а str2 --  это \textbf{abcdef}, тогда наш массив будет dp[6][7], а окончательный ответ - dp[5][6].

\begin{tcolorbox}
\begin{verbatim}
    |   |(a)|(b)|(c)|(d)|(e)|(f)|
+---+---+---+---+---+---+---+---+
|   | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
+---+---+---+---+---+---+---+---+
|(a)| 1 |   |   |   |   |   |   |   
+---+---+---+---+---+---+---+---+
|(z)| 2 |   |   |   |   |   |   |   
+---+---+---+---+---+---+---+---+
|(c)| 3 |   |   |   |   |   |   |   
+---+---+---+---+---+---+---+---+
|(e)| 4 |   |   |   |   |   |   |   
+---+---+---+---+---+---+---+---+
|(f)| 5 |   |   |   |   |   |   |   
+---+---+---+---+---+---+---+---+
\end{verbatim}
\end{tcolorbox}

\newpage

Для \textbf{dp[1][1]} мы должны проверить, что мы можем сделать, чтобы преобразовать \textbf{a} в \textbf{a}. Это будет \textbf{0}. Для \textbf{dp[1][2]} мы должны проверить, что мы можем сделать, чтобы преобразовать \textbf{a} в \textbf{ab}. Это будет \textbf{1}, потому что мы должны \textbf{вставить b}. Поэтому после 1-й итерации наш массив будет выглядеть так.

\begin{tcolorbox}
\begin{verbatim}
	|   |(a)|(b)|(c)|(d)|(e)|(f)|
+---+---+---+---+---+---+---+---+
|   | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
+---+---+---+---+---+---+---+---+
|(a)| 1 | 0 | 1 | 2 | 3 | 4 | 5 |
+---+---+---+---+---+---+---+---+
|(z)| 2 |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|(c)| 3 |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|(e)| 4 |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|(f)| 5 |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
\end{verbatim}
\end{tcolorbox}

Для итерации 2

\vspace{\baselineskip}

Для \textbf{dp[2][1]} мы должны проверить, что для преобразования \textbf{az} в \textbf{a} нам нужно удалить \textbf{z}, поэтому \textbf{dp[2][1]} будет \textbf{1}. Аналогично для \textbf{dp[2][2]}, где нам нужно заменить \textbf{z} с \textbf{b}, следовательно, \textbf{dp[2][2]} будет \textbf{1}. Так что после 2-й итерации наш массив \textbf{dp[]} будет выглядеть так.

\begin{tcolorbox}
\begin{verbatim}
    |   |(a)|(b)|(c)|(d)|(e)|(f)|
+---+---+---+---+---+---+---+---+
|   | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
+---+---+---+---+---+---+---+---+
|(a)| 1 | 0 | 1 | 2 | 3 | 4 | 5 |
+---+---+---+---+---+---+---+---+
|(z)| 2 | 1 | 1 | 2 | 3 | 4 | 5 |
+---+---+---+---+---+---+---+---+
|(c)| 3 |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|(e)| 4 |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
|(f)| 5 |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+
\end{verbatim}
\end{tcolorbox}

Наша \textbf{формула} будет выглядеть так:

\begin{tcolorbox}
\begin{minted}{C}
if characters are same
	//если символы равны
	//приравниваем элемент верхнему левому по диагонали
	dp[i][j] = dp[i-1][j-1];
else
	//иначе, приравниваем единице плюс минимальный из левого, верхнего и 
	//верхнего левого по диагонали
	dp[i][j] = 1 + Min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
\end{minted}
\end{tcolorbox}

После последней итерации наш массив dp[] будет выглядеть так.

\newpage

\begin{tcolorbox}
\begin{verbatim}
    |   |(a)|(b)|(c)|(d)|(e)|(f)|
+---+---+---+---+---+---+---+---+
|   | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
+---+---+---+---+---+---+---+---+
|(a)| 1 | 0 | 1 | 2 | 3 | 4 | 5 |
+---+---+---+---+---+---+---+---+
|(z)| 2 | 1 | 1 | 2 | 3 | 4 | 5 |
+---+---+---+---+---+---+---+---+
|(c)| 3 | 2 | 2 | 1 | 2 | 3 | 4 |
+---+---+---+---+---+---+---+---+
|(e)| 4 | 3 | 3 | 2 | 2 | 2 | 3 |
+---+---+---+---+---+---+---+---+
|(f)| 5 | 4 | 4 | 2 | 3 | 3 | 3 |
+---+---+---+---+---+---+---+---+
\end{verbatim}
\end{tcolorbox}

\textbf{Реализация на Java}

\begin{tcolorbox}
\begin{minted}{java}

public int getMinConversions(String str1, String str2){
	//функция поиска количества элементарных изменений в строке 1 
	//для приведения к строке 2
	//создаем массив из с количеством строк: длина первой строки плюс один, 
	//и количеством столбцов: длина второй строки плюс один
	int dp[][] = new int[str1.length()+1][str2.length()+1];
	//цикл, количество итераций которого равен длине первой строки
	for(int i=0;i<=str1.length();i++){
		//вложенный цикл, количество итераций которого равен длине второй строки
		for(int j=0;j<=str2.length();j++){
			//если это первая итерация внешнего цикла
			if(i==0)
				//заполняем первую строку номерами столбцов
				dp[i][j] = j;
				//если это первый столбец
			else if(j==0)
				//заполняем первый столбец номерами строк
				dp[i][j] = i;
				//иначе если i-1 символ первой строки и j-1 символ второй 
				//строки равны
			else if(str1.charAt(i-1) == str2.charAt(j-1))
				// приравниваем элемент верхнему левому по диагонали
				dp[i][j] = dp[i-1][j-1];
				//иначе
			else{
				//иначе, приравниваем единице плюс минимальный из левого, 
				//верхнего и верхнего левого по диагонали
				dp[i][j] = 1 + Math.min(dp[i-1][j], Math.min(dp[i][j-1], 
				dp[i-1][j-1]));
			}
		}
	}
	//возвращаем нижний правый элемент массива
	return dp[str1.length()][str2.length()];
}

\end{minted}
\end{tcolorbox}