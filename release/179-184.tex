%Велесов

\chapter*{Глава 39: Поиск}
\section*{Раздел 39.1: Бинарный поиск}

\vspace{\baselineskip}
\textbf{Введение}

\vspace{\baselineskip}
Бинарный поиск - алгоритм поиска “разделяй и властвуй”. Он использует время O (log n) для нахождения элемента в поисковом пространстве, где n ---  размер поискового пространства. 

\vspace{\baselineskip}
Бинарный поиск работает за счет сокращения вдвое пространства поиска вдвое на каждой итерации после сравнения целевого значения со средним значением поискового пространства.

\vspace{\baselineskip}
Чтобы использовать бинарный поиск, поисковое пространство должно быть упорядочено (отсортировано) каким-либо образом. Дублирующие записи (сравниваемые по функции сравнения) нельзя различить, хотя они не нарушают свойство бинарного	 поиска.

\vspace{\baselineskip}
Обычно мы используем меньше (<) в качестве функции сравнения. Если а < b, она вернёт истину. Если а не меньше b и b не меньше а, то а и b равны.

\vspace{\baselineskip}
\textbf{Пример вопроса}
\vspace{\baselineskip}

Вы экономист, но довольно плохой. Перед вами поставлена задача поиска равновесной цены (то есть цены, где предложение равно спросу) на рис. 

\textit{Помните, что чем выше цена, тем больше предложение и тем меньше спрос…}

Поскольку ваша компания очень эффективна в вычислении рыночных сил, вы можете мгновенно получить предложение и спрос в единицах измерения риса, когда цена на рис установлена по определенной цене р . 

Ваш босс хочет получить равновесную цену как можно скорее, но говорит, что равновесная цена может быть положительным целым числом, не превосходящим 10\^17 и гарантированно будет 1 положительное целое решение в диапазоне. Так что приступайте к работе, прежде чем ее потерять! 

Вы можете вызвать функции getSupply(k) и getDemand(k), которые будут делать именно то, что указано в задаче.

\vspace{\baselineskip}
\textbf{Объяснение примера}
\vspace{\baselineskip}

Здесь наше поисковое пространство составляет от 1 до 10\^17 . Таким образом, линейный поиск неосуществим.

\vspace{\baselineskip}
Обратите внимание, что, когда k растёт, getSupply(k) увеличивается, а getDemand(k) уменьшается. Таким образом, для любого х > у , getSupply(x) - getDemand(x) > getSupply(y) - getDemand(y) . Таким образом, это поисковое пространство монотонно и мы можем использовать двоичный поиск.

\vspace{\baselineskip}
Следующий псевдокод демонстрирует использование бинарного поиска.

\vspace{\baselineskip}
\begin{minted}{C}
	
high = 100000000000000000		// Верхняя грань поиска
low = 1					// Нижняя грань поиска
while high - low > 1			// Пока есть в диапазоне более 1 элемента
mid = (high + low) / 2		// Берем середину
supply = getSupply(mid)			
demand = getDemand(mid)
if supply > demand		// Если текущее число больше искомого
high = mid		// Решение находится в меньшей половине
else if demand > supply		
low = mid		// Решение находится в большей половине
else				// Условие supply==demand
return mid		// Решение найдено!

\end{minted}


\newpage
Алгоритм работает за ~O (log 10\^17). Можно обобщить до ~O (log S) времени, где S --- размер пространства поиска, поскольку на каждой итерации цикла while мы вдвое сокращаем пространство поиска ( от [\textit{низкого:высокого}] до  [\textit{низкого:среднего}] или  [\textit{среднего:высокого}])

\vspace{\baselineskip}
Реализация бинарного поиска с помощью рекурсии на С
\vspace{\baselineskip}

\begin{minted}{C} 
//Функция возвращает индекс искомого элемента
// Если элемент не был найден, то функция вернет -1
int binsearch(int a[], int x, int low, int high) {
int mid;
// low больше high, значит, элемент не был найден
if (low > high)
return -1;
	// Берем середину
mid = (low + high) / 2;
// Элемент найден
if (x == a[mid]) {
return (mid);
} else
// Если середина больше, то
if (x < a[mid]) {
	// Ищем в меньшей половине
binsearch(a, x, low, mid - 1);
} else {
	// Ищем в большей половине
binsearch(a, x, mid + 1, high);
}
}
\end{minted}
\vspace{\baselineskip}
\section*{Раздел 39.2: Рабин Карп}
\vspace{\baselineskip}
Алгоритм Рабина -- Карпа или алгоритм Карпа -- Рабина --- это алгоритм поиска строк, который использует хеширование для нахождения любого набора шаблонов строк в тексте. Его среднее и лучшее время работы составляет O(n+m) в пространстве O(p), но его худшее время O(nm), где n --- длина текста, m --- длина шаблона.

\vspace{\baselineskip}
Реализация алгоритма в java для сопоставления строк

\vspace{\baselineskip}
\begin{minted}{C} 
void RabinfindPattern(String text,String pattern){
/*
q - Простое число
p - хеш-значение для pattern
t - хеш-значение для text
d - мощность алфавита
*/
int d=128;
int q=100;
int n=text.length();
int m=pattern.length();
int t=0,p=0;
int h=1;
int i,j;
// Вычисляем хеш-значение для h,
for (i=0;i<m-1;i++)
	// h - коэффициент хеша для первой буквы подстроки
h = (h*d)%q;
// Вычисляем хеш для подстроки начала text’а (размером m) и pattern
for (i=0;i<m;i++){
p = (d*p + pattern.charAt(i))%q;
t = (d*t + text.charAt(i))%q;
}
// Поиск шаблона в строке
for(i=0;i<n-m;i++){
	// Если хеши p и t совпадают
// проверим на совпадение символов посимвольно
if(p==t){
for(j=0;j<m;j++)
// Если нашли несовпадение
if(text.charAt(j+i)!=pattern.charAt(j))
break;
		// Если мы дошли до конца цикла и i - адекватное число
// Мы нашли шаблон в тексте по индексу i
if(j==m && i>=start)
System.out.println("Pattern match found at index "+i);
}
// Если ещё не конец текста
if(i<n-m){
	// Перевычислим хеш для следующей подстроки
	// Т.к мы текущую подстроку передвигаем на символ вперед 
	// Вычитаем из t хеш первой буквы и прибавляем хеш последней
t =(d*(t - text.charAt(i)*h) + text.charAt(i+m))%q;
// Если Хеш оказался отрицательным, прибавим q
if(t<0) t=t+q;
}
}
}
\end{minted}

\newpage

При расчете хеш-значения мы делим его на простое число, чтобы избежать столкновения. После деления на простое число шансы столкновения будут меньше, но тем не менее есть шанс, что значение хеша может быть одинаковым для двух строк, так что, когда мы получим совпадение, мы должны проверить его символ за символом, чтобы убедиться, что мы получили правильное совпадение.

\vspace{\baselineskip}
t =(d*(t - text.charAt(i)*h) + text.charAt(i+m))%q;

\vspace{\baselineskip}
Это делается для того, чтобы пересчитать хеш-значение для шаблона, сначала удалив левый символ, а затем добавив новый символ из текста.

\vspace{\baselineskip}
\section*{Раздел 39.3: Анализ линейного поиска (худший, средний и лучший случаи)}

\vspace{\baselineskip}
У нас может быть три случая для анализа алгоритма: 

\vspace{\baselineskip}
1.Худший случай 

\vspace{\baselineskip}
2.Средний случай

\vspace{\baselineskip}
3.Лучший случай

\vspace{\baselineskip}
\begin{minted}{C} 
#include <stdio.h>
// Линейный поиск x в arr[]. Если x находится в arr[], вернем его индекс,
// Иначе вернем -1
int search(int arr[], int n, int x) {
int i;
// Пробегаем по массиву arr[] от 0 до n
for (i=0; i<n; i++) {
	// Если x найден, вернем его индекс
if (arr[i] == x)
return i;
}
	return -1;
}

/* Программа-тестер*/
int main() {
int arr[] = {1, 10, 30, 15};
int x = 30;
// n - количество элементов в arr[]
// Делим на размер arr[0], так как
// каждый элемент может занимать несколько байт
int n = sizeof(arr)/sizeof(arr[0]);
printf("%d is present at index %d", x, search(arr, n, x));
// Задержка вывода программы
// Нажатием любой клавиши закончим программу
getchar();
return 0;
}
\end{minted}


\newpage

\textbf{Анализ худшего случая (обычно проводится)} 

\vspace{\baselineskip}

В худшем случае мы вычисляем верхнюю границу времени работы алгоритма. Мы должны знать о том, что является причиной проведения максимального числа операций. Для линейного поиска худший случай возникает, когда элемент, подлежащий поиску (х в указанном выше коде), не присутствует в массиве. Когда х не присутствует, функции поиска() сравнивают его со всеми элементами arr[] один за другим. Следовательно, в худшем случае временная сложность линейного поиска будет O(n).

\vspace{\baselineskip}
\textbf{Анализ среднего случая (иногда проводится)}

\vspace{\baselineskip}
В среднем случае мы берём все возможные входные данные и рассчитываем время вычисления для них. Суммируем все рассчитанные значения и делим сумму на общее число вводимых ресурсов. Мы должны знать (или предугадать) распределение случаев. Для задачи линейного поиска давайте предположим, что все случаи равномерно распределены (включая случай, когда х не присутствует в массиве). Таким образом, мы суммируем все случаи и делим сумму на (n+1). Ниже приведено значение средней временной сложности случая.

\vspace{\baselineskip}
\begin{tcolorbox}

Время Среднего случая = $\frac{\sum^{n+1}_{i=1} O(i)}{n+1}=\frac{O((n+1)*(n+2)/2)}{n+1}=O(n)$

\end{tcolorbox}

\vspace{\baselineskip}
\textbf{Анализ наилучшего случая (подделка)}

\vspace{\baselineskip}
В лучшем случае мы вычисляем нижнюю границу времени работы алгоритма. Мы должны знать, что вызывает минимальное число операций, подлежащих выполнению. В задаче линейного поиска лучший случай возникает тогда, когда х присутствует на первой позиции. Число операций в лучшем случае является постоянным (не зависящим от n). Таким образом, временная сложность в лучшем случае будет O(1). Чаще всего мы проводим анализ худшего случая для анализа алгоритмов. В худшем случае мы гарантируем верхний предел времени работы алгоритма, который является хорошей информацией. Средний анализ не является простым в большинстве случаев и проводится редко. В среднем мы должны знать (или предсказывать) математическое распределение всех возможных входных данных. Анализ в лучшем случае --- подделка. Гарантия нижней границы алгоритма не дает никакой информации, так как в худшем случае алгоритм может работать годами.

\vspace{\baselineskip}
Для некоторых алгоритмов все случаи асимптотически одинаковы, т.е. нет худших и лучших случаев. Например, сортировка слиянием выполняет операции O(nLogn) во всех случаях. Большинство других алгоритмов сортировки имеют худшие и лучшие случаи. Например, в типичной реализации быстрой сортировки (где поворот выбран в качестве углового элемента) худший случай, когда входной массив уже отсортирован, и лучший случай, когда узловые элементы всегда делят массив на две половины. Для сортировки вставками худший случай возникает при обратной сортировке массива и лучший случай возникает тогда,
когда массив сортируется в том же порядке, что и вывод.

\newpage

\section*{Раздел 39.4: Бинарный поиск: на отсортированных числах}

\vspace{\baselineskip}
Очень легко показать бинарный поиск на числах , используя псевдокод

\vspace{\baselineskip}
\begin{minted}{C} 
int array[1000] = { /*отсортированный массив данных*/ };
// Количество обрабатываемых чисел
int N = 100;
// Верхняя, нижняя грани и середина
int high, low, mid; 
// Искомое значение
int x;
low = 0;
high = N -1;
while(low < high)
{	
	// Берем середину
mid = (low + high)/2;
//Если искомое число больше
if(array[mid] < x)
	// Смещаем нижнюю грань на середину
low = mid + 1;
else
// Смещаем верхнюю грань на середину
high = mid;
}
if(array[low] == x)
// Значение найдено
else
// Значение не найдено
\end{minted}

\vspace{\baselineskip}
Не пытайтесь вернуть значение раньше времени, сравнивая array[mid] с x для равенства. Дополнительное сравнение может только замедлить код. Обратите внимание, что нужно добавить ещё одно сравнение, дабы избежать попадания в ловушку целочисленного деления, которое всегда округляет вниз.

\vspace{\baselineskip}
Интересно отметить, что вышеупомянутая версия бинарного поиска позволяет найти наименьшее число Х в массиве. Если массив содержит дубликаты х, алгоритм может быть слегка изменен, чтобы он вернул наибольшую частоту х, просто добавив условие:

\vspace{\baselineskip}
\begin{minted}{C} 
while(low < high)
{
	// Ищем середину
// Мы не складываем high+low, чтобы избежать переполнения
mid = low + ((high - low) / 2);
// Если x больше ИЛИ есть дубликат с бóльшим индексом
if(array[mid] < x || (array[mid] == x && array[mid + 1] == x))
	// Смещаем нижнюю грань
low = mid + 1;
else
	// Смещаем верхнюю грань
high = mid;
}
\end{minted}

\vspace{\baselineskip}
Заметим, что вместо того, чтобы делать mid = ( low+high ) / 2 , можно также  попробовать mid = low ( ( high - low ) / 2 ) для реализаций, таких как реализация Java, чтобы снизить риск получения переполнения для действительно больших входных данных.

\vspace{\baselineskip}
\section*{Раздел 39.5: Линейный поиск}

\vspace{\baselineskip}
Линейный поиск --- простой алгоритм. Он обходит элементы до тех пор, пока не будет найден запрос, линейным алгоритмом его делает сложность O(n), где n - число элементов, через которые нужно пройти. 

\vspace{\baselineskip}
Почему O(n)? В худшем случае вам придется просмотреть все n пунктов.

\vspace{\baselineskip}
Это можно сравнить с поиском книги в стопке книг: просмотрите их все, пока не найдете ту, которая вам нужна.

\vspace{\baselineskip}
Ниже приводится реализация на Python:
\begin{minted}{Python} 
# searchable_list - поисковый список,
# query - искомый элемент
# Возвращает True, если элемент в списке есть, иначе False
def linear_search(searchable_list, query):
for x in searchable_list:
if query == x:
return True
return False
linear_search(['apple', 'banana', 'carrot', 'fig', 'garlic'], 'fig') #возвращает True
\end{minted}
