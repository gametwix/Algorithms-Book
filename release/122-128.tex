%Мохляков

\section*{Раздел 20.2. Обнаружение отрицательного цикла в графе}

Чтобы понять этот пример, рекомендуется иметь краткое представление об алгоритме Беллмана- Форда, которое можно найти здесь

\vspace{\baselineskip}

Используя алгоритм Беллмана- Форда, мы можем определить, есть ли отрицательный цикл на нашем графике. Мы знаем, что для того , чтобы узнать кратчайший путь, нам нужно ослабить все ребра графа \textbf{(V- 1)} раз, где \textbf{V} -  количество вершин в графе. Мы уже видели, что в этом примере после \textbf{(V- 1)} итераций мы не можем обновить \textbf{d[]}, независимо от того, сколько итерации мы делаем. Или можем?

\vspace{\baselineskip}

Если в графе есть отрицательный цикл, даже после \textbf{(V- 1)} итераций, мы можем обновить \textbf{d[]}. Это происходит потому, что для каждой итерации, проходящей через отрицательный цикл, всегда уменьшается стоимость кратчайшего пути. Вот почему алгоритм Беллман- Форда ограничивает количество итераций до \textbf{(V- 1)}. Если бы мы использовали алгоритм Дейкстры здесь, мы бы застряли в бесконечном цикле. Однако давайте сосредоточимся на поиске отрицательного цикла

\vspace{\baselineskip}

Предположим, у нас есть график:

\includeimage{0.75}{images/122_1.pdf}

Давайте выберем \textbf{вершину 1} в качестве \textbf{источника. После примене}ния алгоритма кратчайшего пути Беллмана- Форда к графу, мы узнаем расстояния от \textbf{источника} до всех остальных вершин.
%\newpage  %можно убрать или переместить после фото потом

\includeimage{0.75}{images/122_2.pdf}

Так выглядит график после \textbf{(V- 1) = 3} итераций. Это должно быть результатом, так как есть \textbf{4} ребра, нам нужно больше \textbf{3} итераций, чтобы узнать кратчайший путь. Так что либо это ответ, либо есть отрицательный цикл в графе. Чтобы выяснить это, после \textbf{(V- 1)} итераций мы делаем еще одну заключительную итерацию и если расстояние продолжает уменьшаться, то это означает, что на графике, определенно, отрицательный весовой цикл.

\vspace{\baselineskip}

Для этого примера: если мы проверим \textbf{2- 3}, \textbf{d[2]} + \textbf{cost[2][3]} даст нам \textbf{1}, что меньше, чем \textbf{d[3]}. Таким образом, мы можем сделать вывод, что на нашем графике есть отрицательный цикл.

\vspace{\baselineskip}

Итак, как мы можем узнать отрицательный цикл? Мы немного изменим процедуру Беллмана- Форда:

\begin{tcolorbox}
\begin{minted}{python}
Procedure NegativeCycleDetector(Graph, source):
n := number of vertices in Graph
# задаем начальные бесконечные расстояния до вершин из source
for i from 1 to n
	# d -  массив расстояний от source
	d[i] := infinity
end for
# Очевидно, что от source до source расстояние 0

d[source] := 0
# Улучшаем расстояние до других вершин.Сделаем n- 1 итераций
for i from 1 to n- 1
	# если flag -  true, то мы нашли меньшее расстояние до другой вершины
	flag := false
	# Проходим по всем ребрам
	for all edges from (u,v) in Graph
	# Если расстояние от вершины u до v меньше, чем было -  обновим
		# расстояние на более оптимальное
		if d[u] + cost[u][v] < d[v]
			d[v] := d[u] + cost[u][v]
			# изменения есть
			flag := true
		end if
	end for
	# А если изменений не было -  нет смысла прогонять ещё итерации
	if flag == false
		break
end for
# Проведем последнюю итерацию
# Если расстояния до других вершин из source уменьшится
# То это укажет на наличие отрицательного цикла
for all edges from (u,v) in Graph
	if d[u] + cost[u][v] < d[v]
	# Уменьшение расстояний произошло
		Return "Negative Cycle Detected"
	end if
end for
Return "No Negative Cycle"
\end{minted}
\end{tcolorbox}

Вот как мы узнаем, существует ли отрицательный цикл в графе. Мы также можем изменить алгоритм Беллмана- Форда, чтобы сохранить путь отрицательных циклов.

\section*{Раздел 20.3: Почему нам нужно ослабить все ребра в (V- 1) раз}

Чтобы понять этот пример, рекомендуется иметь краткое представление об алгоритме Беллмана- Форда с одним источником кратчайшего пути который можно найти здесь.

\vspace{\baselineskip}

В алгоритме Беллмана- Форда, чтобы найти кратчайший путь, нам нужно ослабить все ребра графа. Этот процесс повторяется не более \textbf{(V- 1)} раз, где \textbf{V} -  количество вершин в графе.

\vspace{\baselineskip}

Количество итераций, необходимое для определения кратчайшего пути от \textbf{источника} ко всем остальным вершинам, зависит от порядка, который мы выбираем, чтобы ослабить ребра.

\vspace{\baselineskip}

Давайте посмотрим на пример:

\includeimage{0.8}{images/123_1.pdf}

Здесь \textbf{исходная} вершина равна 1. Выясним кратчайшее расстояние между \textbf{источником} и всеми остальными вершинами. Мы можем ясно видеть, что для достижения \textbf{вершины 4} в худшем случае потребуется \textbf{(V- 1)} ребер. Теперь в зависимости от доступности, какие ребра обнаружены, это может занять \textbf{(V- 1)} раз, чтобы обнаружить вершину \textbf{4}. Не поняли? Давайте использовать алгоритм Беллман- Форда поиска кратчайшего пути здесь:

\vspace{\baselineskip}

Мы собираемся использовать эту последовательность:

\begin{tcolorbox}
{\tiny+ -  -  -  -  -  -  -  -  -  + -  -  -  -  -  -  -  -  + -  -  -  -  -  -  -  -  + -  -  -  -  -  -  -  -  +}

\hspace{0.4mm}|\hspace{2.7mm}Номер\hspace{2.7mm}|\hspace{6.82mm}1\hspace{6.82mm}|\hspace{6.82mm}2\hspace{6.82mm}|\hspace{6.82mm}3\hspace{6.82mm}|

{\tiny+ - - - - - - - - - + - - - - - - - - + - - - - - - - - + - - - - - - - - +}

\hspace{0.4mm}|\hspace{3mm}Грань\hspace{3mm}|\hspace{3.55mm}3->4\hspace{3.55mm}|\hspace{3.55mm}2->3\hspace{3.55mm}|\hspace{3.55mm}1->2\hspace{3.55mm}|

{\tiny+ - - - - - - - - - + - - - - - - - - + - - - - - - - - + - - - - - - - - +}
\end{tcolorbox}

Для нашей первой итерации:

\begin{enumerate}
\item \textbf{d[3] + cost[3][4] = infinity.} Это ничего не изменит.
\item \textbf{d[2] + cost[2][3] = infinity.} Это ничего не изменит.
\item \textbf{d[1] + cost[1][2] = 2 < d[2]. d[2] = 2. parent[2] = 1.}
\end{enumerate}

Мы видим, что наш процесс ослабления изменился только в \textbf{d[2]}. Наш график будет
выглядеть так:

\includeimage{0.8}{images/124_1.pdf}

Вторая итерация:

\begin{enumerate}
\item \textbf{d[3] + cost[3][4] = infinity.} Это ничего не изменит.
\item \textbf{d[2] + cost[2][3] = 5 < d[3]. d[3] = 5. parent[3] = 2.}
\item Это не будет изменено.
\end{enumerate}

На этот раз процесс ослабления изменился на \textbf{d[3]}. Наш график будет выглядеть так:

\includeimage{0.8}{images/124_2.pdf}

Третья итерация:

\begin{enumerate}
\item \textbf{d[3] + cost[3][4] = 7 < d[4]. d[4] = 7. parent[4] = 3.}
\item Это не будет изменено.
\item Это не будет изменено.
\end{enumerate}

Наша третья итерация наконец нашла кратчайший путь до \textbf{4} из \textbf{1}. Наш график будет выглядеть так:

\includeimage{0.8}{images/124_3.pdf}

Итак, потребовалось \textbf{3} итерации, чтобы найти кратчайший путь. После этого, сколько бы раз мы ни \textit{расслабляли} края, значения в \textbf{d[]} останутся прежними. Теперь, если мы рассмотрим другую последовательность:

\begin{tcolorbox}
{\tiny+ -  -  -  -  -  -  -  -  -  + -  -  -  -  -  -  -  -  + -  -  -  -  -  -  -  -  + -  -  -  -  -  -  -  -  +}

\hspace{0.4mm}|\hspace{2.7mm}Номер\hspace{2.7mm}|\hspace{6.82mm}1\hspace{6.82mm}|\hspace{6.82mm}2\hspace{6.82mm}|\hspace{6.82mm}3\hspace{6.82mm}|

{\tiny+ - - - - - - - - - + - - - - - - - - + - - - - - - - - + - - - - - - - - +}

\hspace{0.4mm}|\hspace{3mm}Грань\hspace{3mm}|\hspace{3.55mm}1->2\hspace{3.55mm}|\hspace{3.55mm}2->3\hspace{3.55mm}|\hspace{3.55mm}3->4\hspace{3.55mm}|

{\tiny+ - - - - - - - - - + - - - - - - - - + - - - - - - - - + - - - - - - - - +}
\end{tcolorbox}

Мы бы получили:

\begin{enumerate}
\item \textbf{d[1] + cost[1][2] = 2 < d[2]. d[2] = 2.}
\item \textbf{d[2] + cost[2][3] = 5 < d[3]. d[3] = 5.}
\item \textbf{d[3] + cost[3][4] = 7 < d[4]. d[4] = 5.}
\end{enumerate}

Наша самая первая итерация нашла кратчайший путь от \textbf{источника} ко всем остальным
узлам. Другая последовательность \textbf{1-> 2, 3-> 4, 2-> 3}, возможно, это даст нам кратчайший
путь после \textbf{2} итераций. Мы можем прийти к решению, независимо от того, как мы
упорядочим последовательность, это займет не более \textbf{3} итераций, чтобы найти кратчайший
путь от \textbf{источника} в этом примере.

\hspace{\baselineskip}

Мы можем заключить, что в лучшем случае потребуется \textbf{1} итерация, чтобы найти
кратчайший путь от \textbf{источника}. Для худшего случая потребуется \textbf{(V-1)} итераций, поэтому мы
повторяем процесс ослабления \textbf{(V-1)} раз.

\chapter*{Глава 21: Линейный алгоритм}
\vspace{-1cm}
Рисование линии осуществляется путем расчета промежуточных положений вдоль пути
между двумя указанными конечными позиции. Затем устройство вывода направляется для
заполнения этих позиций между конечными точками.

\section*{Раздел 21.1: Алгоритм рисования линий Брезенхэма}

Теория фона: алгоритм рисования линий Брезенхэма - это эффективная и точная генерация
растровых линий алгоритмом, разработанным Брезенхэмом. Он включает в себя только
целочисленные вычисления, поэтому он точный и быстрый. Он также может быть расширен
для отображения кругов разных характеристик.

Алгоритм рисования линий Брезенхэма:

При наклоне |m|<1:

Либо значение x увеличивается

ИЛИ оба значения x и y увеличиваются с помощью параметра решения.

При наклоне |m|>1:

Либо значение y увеличивается

ИЛИ оба значения x и y увеличиваются с помощью параметра решения.

\textbf{Алгоритм для наклона |m|<1:}
\begin{enumerate}
\item Ввести две точки: (x1,y1) и (x2,y2)
\item Нарисовать точку (x1,y1): plot(x1,y1).
\item {\setlength{\parskip}{0cm}Вычислить

Delx = |x2 – x1|

Dely = |y2 – y1|}
\item {\setlength{\parskip}{0cm}Получить начальный параметр решения:

p = 2 * dely – delx}
\item {\setlength{\parskip}{0cm}Для i от 0 до delx с шагом 1:

Если p < 0, то

x1 = x1 + 1

plot(x1,y1)

p = p + 2dely

Иначе,

x1 = x1 + 1

y1 = y1 + 1

plot(x1,y1)

p = p + 2dely – 2 * delx

Конец Если

Конец Для}

\item Конец
\end{enumerate}
\newpage
\textbf{Исходный код на Си:}

\begin{tcolorbox}
\begin{minted}{C}
/* Программа на Си с реализацией алгоритма Брезенхэма для рисования линий для |m|<1 */
#include<stdio.h>
#include<conio.h>
#include<graphics.h>
#include<math.h>
int main()
{
	int gdriver=DETECT,gmode;
	int x1,y1,x2,y2,delx,dely,p,i;
	// Инициализируем график
	initgraph(&gdriver,&gmode,"C:\\TC\\BGI");
	printf("Enter the intial points: ");
	scanf("%d",&x1);
	scanf("%d",&y1);
	printf("Enter the ent points: ");
	scanf("%d",&x2);
	scanf("%d",&y2);
	// Рисуем начальную точку красным цветом
	putpixel(x1,y1,RED);
	// Вычисляем расстояние по Ox и Oy от начальной точки до конечной
	delx=fabs(x2-x1);
	dely=fabs(y2-y1);
	// Вычисляем параметр решения
	p=(2*dely)-delx;
	// Проходим по всем x от 0 до delx.
	// Не по dely, потому что наклон |m|<1, то есть наклон пологий
	for(i=0;i<delx;i++){
		// В зависимости от параметра p рисуем пиксель
		// либо по Ox, либо еще со смещением по Oy
		if(p<0)
		{
			x1=x1+1;
			putpixel(x1,y1,RED);
			p=p+(2*dely);
		}
		else
		{
			x1=x1+1;
			
			y1=y1+1;
			putpixel(x1,y1,RED);
			p=p+(2*dely)-(2*delx);
		}
	}
	// Задержка графика, график закроется нажатием любой клавиши
	getch();
	// Закрытие графика. Окончание программы
	closegraph();
	return 0;
}
\end{minted}
\end{tcolorbox}


\textbf{Алгоритм для наклона |m|>1:}
\begin{enumerate}
\item Ввести две точки: (x1,y1) и (x2,y2)
\item Нарисовать точку (x1,y1): plot(x1,y1).
\item {\setlength{\parskip}{0cm}Вычислить

Delx =| x2 – x1 |

Dely = | y2 – y1 |
}
\item {\setlength{\parskip}{0cm}Получить начальный параметр решения:

p = 2 * delx – dely}

\item {\setlength{\parskip}{0cm}Для i от 0 до dely с шагом 1:

Если p < 0, то

x1 = x1 + 1

plot(x1,y1)

p = p+ 2delx

Иначе,

x1 = x1 + 1

y1 = y1 + 1

plot(x1,y1)

p = p + 2delx – 2 * dely

Конец Если

Конец Для}

\item Конец
\end{enumerate}

\textbf{Исходный код на Си:}
\begin{tcolorbox}
\begin{minted}{C}
/* Программа на Си с реализацией алгоритма Брезенхэма для рисования линий для |m|<1 */
#include<stdio.h>
#include<conio.h>
#include<graphics.h>
#include<math.h>
int main()
{
	int gdriver=DETECT,gmode;
	
	int x1,y1,x2,y2,delx,dely,p,i;
	// Инициализируем график
	initgraph(&gdriver,&gmode,"C:\\TC\\BGI");
	printf("Enter the intial points: ");
	scanf("%d",&x1);
	scanf("%d",&y1);
	printf("Enter the ent points: ");
	scanf("%d",&x2);
	scanf("%d",&y2);
	// Рисуем начальную точку красным цветом
	putpixel(x1,y1,RED);
	// Вычисляем расстояние по Ox и Oy от начальной точки до конечной
	delx=fabs(x2-x1);
	dely=fabs(y2-y1);
	// Вычисляем параметр решения
	p=(2*delx)-dely;
	// Проходим по всем y от 0 до dely.
	// Не по delx, потому что наклон |m|>1, то есть наклон крутой
	for(i=0;i<dely;i++){
		// В зависимости от параметра p рисуем пиксель
		// либо по Oy, либо еще со смещением по Ox
		if(p<0)
		{
			y1=y1+1;
			putpixel(x1,y1,RED);
			p=p+(2*delx);
		}
		else
		{
			x1=x1+1;
			y1=y1+1;
			putpixel(x1,y1,RED);
			p=p+(2*delx)-(2*dely);
		}
	}
	// Задержка графика
	// График закроется нажатием любой клавиши
	getch();
	// Закрытие графика. Окончание программы
	closegraph();
	return 0;
}
\end{minted}
\end{tcolorbox}