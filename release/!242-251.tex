%Почаев

\chapter*{Глава 53: Алгоритм минимального вершинного покрытия}
\vspace{-0.4cm}

\textbf{Переменная}	\hspace*{15mm} \textbf{Значение}

\vspace{\baselineskip}
\vspace{-0.4cm}
G      \hspace*{10mm}     Исходный связный неориентированный граф

\vspace{\baselineskip}
\vspace{-0.4cm}
X	   \hspace*{10mm}     Множество вершин

\vspace{\baselineskip}
\vspace{-0.4cm}
C	   \hspace*{10mm}     Окончательное множество вершин

\vspace{\baselineskip}
Это полиномиальный алгоритм для нахождения минимального вершинного покрытия связного неориентированного графа. Временная сложность этого алгоритма равна О($n^2$)

\section*{Псевдокод алгоритма}
\vspace{-0.2cm}

\vspace{\baselineskip}
\vspace{-0.4cm}
\textbf{Алгоритм PMinVertexCover (граф G)}

\vspace{\baselineskip}
\vspace{-0.4cm}
\textbf{Входной подключенный граф G}

\vspace{\baselineskip}
\vspace{-0.4cm}
\textbf{Выходная минимальная вершина C}

\begin{tcolorbox}
\begin{minted}{C}

Set C <- new Set<Vertex>()

Set X <- new Set<Vertex>()

X <- G.getAllVerticiesArrangedDescendinglyByDegree()

for v in X do
	List<Vertex> adjacentVertices1 <- G.getAdjacent(v)
	
	if !C contains any of adjacentVertices1 then

		C.add(v)
		
for vertex in C do

	List<vertex> adjacentVertices2 <- G.adjacentVertecies(vertex)
	
	if C contains any of adjacentVertices2 then

		C.remove(vertex)

return C

\end{minted}
\end{tcolorbox}

\pline{0.3}{С – это минимальное вершинное покрытие графа G}

\vspace{\baselineskip}
\vspace{-0.2cm}
\pline{0.6}{мы можем использовать блочную сортировку вершин по их степени, потому что максимальное значение степеней равно (n-1), где n – число вершин. Временная сложность алгоритма сортировки будет равна О(n)}

\chapter*{Глава 54:  Динамическая трансформация временной шкалы (DTW)}
\section*{Раздел 54.1: Введение в динамическую трансформацию временной шкалы (DTW)}

\href{https://en.wikipedia.org/wiki/Dynamic_time_warping}{\underline{Алгоритм динамической трансформации временной шкалы}} (DTW) - это алгоритм измерения сходства между двумя временными последовательностями, которые могут различаться по скорости. Например, сходство в ходьбе может быть обнаружено с помощью DTW, даже если один человек шел быстрее другого, или если человек ускорялся и замедлялся. Алгоритм может использоваться для сопоставления образца голосовой команды с другими командами, даже если человек произнес ее быстрее или медленнее заранее записанного образца. DTW может быть применен к временным последовательностям видео-, аудио- и графических данных. На самом деле любые данные, которые можно преобразовать в линейную последовательность, могут быть обработаны с помощью DTW.

\vspace{\baselineskip}
В целом, DTW – это метод, который вычисляет оптимальное соответствие между двумя заданными последовательностями с определенными ограничениями. Но давайте остановимся на более простых моментах. Скажем, у нас есть две голосовые последовательности: \textbf{Sample} и \textbf{Test}, и мы хотим проверить, совпадают ли эти последовательности или нет. Здесь голосовая последовательность строится по преобразованному цифровому сигналу вашего голоса. Это может быть амплитуда или частота вашего голоса, обозначающие слова, которые вы произнесли. Давайте предположим:


\vspace{\baselineskip}
\begin{tcolorbox}
\begin{minted}{C}

Sample = {1, 2, 3, 5, 5, 5, 6}
Test = {1, 1, 2, 2, 3, 5}

\end{minted}
\end{tcolorbox}

\vspace{\baselineskip}
Мы хотим найти оптимальное соответствие между этими двумя последовательностями.

Сначала мы определим расстояние между двумя точками d(x, y), где \textbf{x} и \textbf{y} - точки. Пусть

\vspace{\baselineskip}
\begin{tcolorbox}
\begin{minted}{C}

d(x, y) = |x - y| // абсолютная разница

\end{minted}
\end{tcolorbox}

\vspace{\baselineskip}
\vspace{-0.2cm}
Давайте создадим двумерную матрицу \textbf{Table}, используя эти две последовательности. Мы рассчитаем расстояния между каждой точкой из \textbf{Sample} с каждой точкой из \textbf{Test} и найдем оптимальное соответствие между ними.

\newpage
\begin{tcolorbox}
\begin{verbatim}
+------+------+------+------+------+------+------+------+
|      |   0  |   1  |   1  |   2  |   2  |   3  |   5  |
+------+------+------+------+------+------+------+------+
|  0   |      |      |      |      |      |      |      |
+------+------+------+------+------+------+------+------+
|  1   |      |      |      |      |      |      |      |
+------+------+------+------+------+------+------+------+
|  2   |      |      |      |      |      |      |      |
+------+------+------+------+------+------+------+------+
|  3   |      |      |      |      |      |      |      |
+------+------+------+------+------+------+------+------+
|  5   |      |      |      |      |      |      |      |
+------+------+------+------+------+------+------+------+
|  5   |      |      |      |      |      |      |      |
+------+------+------+------+------+------+------+------+
|  5   |      |      |      |      |      |      |      |
+------+------+------+------+------+------+------+------+
|  6   |      |      |      |      |      |      |      |
+------+------+------+------+------+------+------+------+
\end{verbatim}
\end{tcolorbox}

\vspace{\baselineskip}
Здесь в \textbf{Table[i][j]} представлено минимальное расстояние между двумя последовательностями, если мы рассматриваем последовательность до \textbf{Sample[i]} и \textbf{Text[j]}, учитывая все минимальные расстояния, найденные ранее.

\vspace{\baselineskip}
В первой строке мы не берем никакие значения из \textbf{Sample}, значит расстояние между \textbf{Sample} и \textbf{Test} будет \textit{бесконечным}. Поэтому мы поместим \textit{бесконечность}(inf) в первую строку. Аналогично и для первого столбца. Если мы не возьмем никакие значения из \textbf{Test}, расстояние между \textbf{Test} и \textbf{Sample} будет также бесконечным. А расстояние между \textbf{0} и \textbf{0} будет равно \textbf{0}. Получим

\begin{tcolorbox}
\begin{verbatim}
+------+------+------+------+------+------+------+------+
|      |   0  |   1  |   1  |   2  |   2  |   3  |   5  |
+------+------+------+------+------+------+------+------+
|  0   |  0   |  inf |  inf |  inf |  inf |  inf |  inf |
+------+------+------+------+------+------+------+------+
|  1   |  inf |      |      |      |      |      |      |
+------+------+------+------+------+------+------+------+
|  2   |  inf |      |      |      |      |      |      |
+------+------+------+------+------+------+------+------+
|  3   |  inf |      |      |      |      |      |      |
+------+------+------+------+------+------+------+------+
|  5   |  inf |      |      |      |      |      |      |
+------+------+------+------+------+------+------+------+
|  5   |  inf |      |      |      |      |      |      |
+------+------+------+------+------+------+------+------+
|  5   |  inf |      |      |      |      |      |      |
+------+------+------+------+------+------+------+------+
|  6   |  inf |      |      |      |      |      |      |
+------+------+------+------+------+------+------+------+
\end{verbatim}
\end{tcolorbox}

\vspace{\baselineskip}
\vspace{-0.2cm}
Теперь для каждого шага мы рассмотрим расстояние между двумя точками и добавим его к минимальному найденному до этого расстоянию. Это даст нам минимальное расстояние между двумя последовательностями до определенной позиции. Итак, наша формула:

\vspace{\baselineskip}
\begin{tcolorbox}
\begin{minted}{C}

Table[i][j] := d(i, j) + min(Table[i-1][j], Table[i-1][j-1], Table[i][j-1])

\end{minted}
\end{tcolorbox}

Для первого шага \textbf{d(1, 1) = 0}, в \textbf{Table[0][0]} представлен минимум. Поэтому значение \textbf{Table[1][1]} будет \textbf{0 + 0 = 0}. Для второго шага \textbf{d(1, 2) = 0}. В \textbf{Table[1][1]} представлен минимум. Значение \textbf{Table[1][2]} будет \textbf{0 + 0 = 0}. Продолжая заполнение таблицы таким же образом, мы получим следующий результат:

\vspace{\baselineskip}
\begin{tcolorbox}
\begin{verbatim}
+------+------+------+------+------+------+------+------+
|      |   0  |   1  |   1  |   2  |   2  |   3  |   5  |
+------+------+------+------+------+------+------+------+
|  0   |  0   |  inf |  inf |  inf |  inf |  inf |  inf |
+------+------+------+------+------+------+------+------+
|  1   |  inf |   0  |  0   |   1  |   2  |  4   |  8   |
+------+------+------+------+------+------+------+------+
|  2   |  inf |   1  |  1   |   0  |   0  |  1   |  4   |
+------+------+------+------+------+------+------+------+
|  3   |  inf |   3  |  3   |   1  |   1  |  0   |  2   |
+------+------+------+------+------+------+------+------+
|  5   |  inf |   7  |  7   |   4  |   4  |   2  |   0  |
+------+------+------+------+------+------+------+------+
|  5   |  inf |  11  |  11  |   7  |   7  |   4  |   0  |
+------+------+------+------+------+------+------+------+
|  5   |  inf |  15  |  15  |  10  |  10  |   6  |   0  |
+------+------+------+------+------+------+------+------+
|  6   |  inf |  20  |  20  |  14  |  14  |   9  |   1  |
+------+------+------+------+------+------+------+------+
\end{verbatim}
\end{tcolorbox}

\vspace{\baselineskip}
\vspace{-0.2cm}
В \textbf{Table[7][6]} представлено максимальное расстояние между двумя заданными последовательностями. Здесь \textbf{1} означает, что максимальное расстояние между \textbf{Sample} и \textbf{Test} равно \textbf{1}.

\vspace{\baselineskip}
Теперь, если мы вернемся назад от последней точки до начальной точки \textbf{(0, 0)}, мы получим длинную линию, которая проходит по горизонтали, вертикали и диагонали. Процедура возврата будет такой:

\vspace{\baselineskip}
\begin{tcolorbox}
\begin{minted}{C}

if Table[i-1][j-1] <= Table[i-1][j] and Table[i-1][j-1] <= Table[i][j-1]
GoalKicker.com – Algorithms Notes for Professionals 240
	i := i - 1
	j := j - 1
else if Table[i-1][j] <= Table[i-1][j-1] and Table[i-1][j] <= Table[i][j-1]
	i := i - 1
else
	j := j - 1
end if

\end{minted}
\end{tcolorbox}

\vspace{\baselineskip}
\vspace{-0.2cm}
Мы продолжим до тех пор, пока не дойдем до \textbf{(0, 0)}. Каждый переход имеет свое значение:

\vspace{-0.1cm}
\begin{itemize}
  \item	Горизонтальное движение - это удаление. Это означает, что последовательность \textbf{Test} ускорилась на этом интервале.
  \vspace{-0.3cm}
  \item	Вертикальное движение – это вставка. Это означает, что последовательность \textbf{Test} замедлилась на этом интервале.
  \vspace{-0.3cm}
   \item Диагональное движение – это совпадение. На этом интервале \textbf{Test} и \textbf{Sample} были одинаковыми.
\end{itemize}

\vspace{\baselineskip}
\includeimage{0.75}{images/245.pdf}

\vspace{-1cm}
Псевдокод:

\begin{tcolorbox}
\begin{minted}{C}

Procedure DTW(Sample, Test):
n := Sample.length
m := Test.length
Create Table[n + 1][m + 1]
for i from 1 to n
	Table[i][0] := infinity
end for
for i from 1 to m
	Table[0][i] := infinity
end for
Table[0][0] := 0
for i from 1 to n
	for j from 1 to m
		Table[i][j] := d(Sample[i], Test[j])
			+ minimum(Table[i-1][j-1],
				Table[i][j-1],
				Table[i-1][j])
	end for
end for
Return Table[n + 1][m + 1]

\end{minted}
\end{tcolorbox}

\vspace{\baselineskip}
\vspace{-0.3cm}
Мы также можем добавить ограничение на место нахождения. То есть, мы требуем, что если Sample[i] совпадает с Test[j], то |i – j| не больше, чем некоторый параметр \textbf{w}.

\vspace{\baselineskip}
\textbf{Сложность:}

Сложность вычисления динамической трансформации временной шкалы равна $\mathbf{O(m*n)}$, где \textbf{m} и \textbf{n} – длины последовательностей. Более быстрые техники вычисления DTW – это PrunedDTW, SparceDTW и FastDTW.

\vspace{\baselineskip}
\textbf{Применение:}

\begin{itemize}
  \item	Распознавание речи
  \item	Корреляционная атака по энергопотреблению
\end{itemize}

\chapter*{Глава 55: Быстрое преобразование Фурье}

\vspace{-0.3cm}
Действительная и комплексная форма ДПФ (\textbf{Д}искретное \textbf{п}реобразование \textbf{Ф}урье, DFT) может быть использована для частотного анализа или синтеза любых дискретных и периодических сигналов. БПФ (\textbf{Б}ыстрое \textbf{п}реобразование \textbf{Ф}урье, FFT) – это реализация ДПФ, которая быстро выполняется на современных процессорах.

\section*{Раздел 55.1: Алгоритм Radix-2 для БПФ}

Самым простым и, возможно, самым известным методом вычисления БПФ является алгоритм Radix-2 с прореживанием по времени. Radix-2 работает путем разложения сигнала N-точечной временной области на N сигналов временной области, каждый из которых состоит из одной точки.

\includeimage{0.32}{images/247.pdf}

Декомпозиция сигнала, или «прореживание по времени», достигается путем реверсирования битов индексов для массива данных временной области. Таким образом, для шестнадцати-точечного сигнала значение 1 (в двоичной системе 0001) заменяется на 8 (1000), значение 2 (0010) заменяется на 4 (0100) и так далее. Перестановка чисел с использованием метода реверса битов может быть легко выполнена на программном уровне, но ограничивает использование алгоритма Radix-2 для БПФ сигналами длины $N=2^M$.

\vspace{\baselineskip}
Значение одноточечного сигнала во временной области равно его значению в частотной области, поэтому массив разложенных одиночных точек временной области является массивом точек частотной области. Однако N единичных точек необходимо преобразовать в один N-точечный частотный спектр. Оптимальное преобразование полного частотного спектра осуществляется с использованием операции «бабочка». На каждом этапе преобразования алгоритм Radix-2 выполняет некоторое число двухточечных «бабочек», используя похожий набор экспоненциальных весовых функций $Wn^R$.

\newpage
\includeimage{0.75}{images/248.pdf}

\vspace{\baselineskip}
БПФ удаляет избыточные вычисления дискретного преобразования Фурье, используя периодичность $Wn^R$. Спектральное преобразование выполняется за log2(N) шагов, на каждом из которых высчитывается X[K] – результат операции «бабочка»; действительные и мнимые данные частотной области в прямоугольной форме. Для преобразования в магнитуду и фазу (полярные координаты) требуется найти абсолютное значение $\sqrt(Re2 + Im2)$ и аргумент tan-1(Im/Re).

\vspace{\baselineskip}
Экспоненциальный весовой коэффициент: $W_N{}^R{} = e^{-j(2 \Pi R/N)} = cos(2 \Pi R/N) - jsin(2 \Pi R/N)$

\vspace{\baselineskip}
N: Количество точек в БПФ

\vspace{\baselineskip}
R: Текущий коэффициент WN: зависит от N, текущего шага БПФ и разделения бабочек на этом шаге

\vspace{\baselineskip}
Ниже показана полная структурная диаграмма «бабочек» алгоритма Radix 2 для восьми-точечного БПФ. Обратите внимание, что входные сигналы были переупорядочены в соответствии с процедурой прореживания по времени, описанной выше.

\newpage
\includeimage{0.24}{images/249.pdf}

БПФ обычно работает с комплексными входными данными и выдает комплексный результат. Для вещественных сигналов мнимая часть может быть установлена на 0, а действительная часть – на входной сигнал x[n], однако можно оптимизировать алгоритм, используя преобразования только действительных данных. Значения $Wn^R$, используемые в процессе преобразования, могут быть определены с помощью экспоненциально взвешенного уравнения.

\vspace{\baselineskip}
Величина R (экспоненциально взвешенная степень) определяется текущим этапом в спектральном преобразовании и результатом «бабочки».

\vspace{\baselineskip}
\textbf{Образец кода (С/С++)}

\vspace{\baselineskip}
Пример кода на С/С++ для вычисления БПФ при помощи алгоритма Radix-2 можно найти ниже. Это простая реализация, которая работает для любого N, где N – степень двойки. Этот алгоритм работает примерно в 3 раза медленнее, чем самая быстрая реализация БПФ, но все же это хорошая основа для будущей оптимизации и изучения алгоритма.

\begin{tcolorbox}
\begin{minted}{C}

#include <math.h>

#define PI 3.1415926535897932384626433832795 
#define TWOPI 6.283185307179586476925286766559 
#define Deg2Rad 0.017453292519943295769236907684886 
#define Rad2Deg 57.295779513082320876798154814105 
#define log10_2 0.30102999566398119521373889472449 // Log10 of 2
#define log10_2_INV 3.3219280948873623478703194294948 // 1/Log10(2)

struct complex
{
public:
	double Re, Im; 
};
bool isPwrTwo(int N, int *M)
{
	*M = (int)ceil(log10((double)N) * log10_2_INV);
	int NN = (int)pow(2.0, *M);
	if ((NN != N) || (NN == 0)) 
		return false;
	return true;
}

void rad2FFT(int N, complex *x, complex *DFT)
{
	int M = 0;
	if (!isPwrTwo(N, &M))
		throw "Rad2FFT(): N must be a power of 2 for Radix FFT";
		
	int BSep; 
	int BWidth;
	int P;
	int j;
	int stage = 1;
	int HiIndex; 
	unsigned int iaddr;
	int ii; 
	int MM1 = M - 1;
	
	unsigned int i;
	int l;
	unsigned int nMax = (unsigned int)N;
	
	double TwoPi_N = TWOPI / (double)N; 
	double TwoPi_NP;
	
	complex WN; 
	complex TEMP;
	complex *pDFT = DFT;
	complex *pLo;
	complex *pHi;
	complex *pX;
	
	for (i = 0; i < nMax; i++, DFT++)
	{
		pX = x + i; 
		ii = 0; 
		iaddr = i; 
		for (l = 0; l < M; l++) 
		{
			if (iaddr & 0x01)
				ii += (1 << (MM1 - l)); 
			iaddr >>= 1; 
			if (!iaddr)
				break;
		}
		DFT = pDFT + ii; 
		DFT->Re = pX->Re; 
		DFT->Im = pX->Im; 
	}
	for (stage = 1; stage <= M; stage++) 
	{
		BSep = (int)(pow(2, stage)); 
		P = N / BSep; 
		BWidth = BSep / 2; 
		TwoPi_NP = TwoPi_N*P;
		
		for (j = 0; j < BWidth; j++) 
		{
			if (j != 0) 
			{
				WN.Re = cos(TwoPi_N*P*j);
				WN.Im = -sin(TwoPi_N*P*j);
			}
			for (HiIndex = j; HiIndex < N; HiIndex += BSep) 
			{
				pHi = pDFT + HiIndex; 
				pLo = pHi + BWidth; 
				
				if (j != 0)
				{
					TEMP.Re = (pLo->Re * WN.Re) - (pLo->Im * WN.Im);
					TEMP.Im = (pLo->Re * WN.Im) + (pLo->Im * WN.Re);
					
					pLo->Re = pHi->Re - TEMP.Re;
					pLo->Im = pHi->Im - TEMP.Im;
					
					pHi->Re = (pHi->Re + TEMP.Re);
					pHi->Im = (pHi->Im + TEMP.Im);
				}
				else
				{
					TEMP.Re = pLo->Re;
					TEMP.Im = pLo->Im;
					
					pLo->Re = pHi->Re - TEMP.Re; 
					pLo->Im = pHi->Im - TEMP.Im;
					
					pHi->Re = (pHi->Re + TEMP.Re);
					pHi->Im = (pHi->Im + TEMP.Im);
				}
			}
		}
	}
	pLo = 0;
	pHi = 0;
	pDFT = 0;
	DFT = 0;
	pX = 0;
}

\end{minted}
\end{tcolorbox}