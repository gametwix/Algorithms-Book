%Чернобаев АА
\chapter*{Глава 13: Алгоритм поиска пути A* }
В этой теме основное внимание будет уделено алгоритму поиска пути A* , как он используется, и почему он работает. 

Примечание для будущих участников: я добавил пример для алгоритма A* на сетке 4x4 без каких-либо препятствий. Пример с препятствиями по-прежнему необходим. 
\section*{Раздел 13.1: Простой пример алгоритма поиска пути A*: Лабиринт без препятствий}
Допустим, у нас есть сетка размером 4 на 4:

\vspace{\baselineskip}

\includeimage{0.75}{images/64_1.pdf}

Давайте предположим, что это лабиринт, хотя там нет стен или препятствий. У нас есть только начальная точка (зелёный квадрат) и конечная точка (красный квадрат). Давайте также предположим, что для того, чтобы перейти от зелёного к красному квадрату, мы не можем двигаться по диагонали. Итак, начиная с зеленого квадрата, давайте посмотрим, к каким квадратам мы можем перейти и выделим их синим цветом:

\vspace{\baselineskip}

\includeimage{0.8}{images/65_1.pdf}

Чтобы выбрать квадрат, на который нужно перейти, необходимо учесть 2 эвристики:
\begin{enumerate}
    \item Значение «g» - это расстояние от зеленого квадрата до этого узла.
    \item Значение «h» - это то, как далеко от красного квадрата находится этот узел.
    \item Значение «f» - это сумма значений «g» и «h». Это число, которое говорит нам, на какой узел перейти.
\end{enumerate}

Чтобы вычислить эти эвристики, мы используем следующую формулу:
\colorbox{gray!10!white}{ \parbox{22em}{distance = abs(from.x - to.x) + abs(from.y - to.y)}}

\vspace{\baselineskip}

Эта формула известна как \href{ссылка}{\color{Purple}"Манхэттенское расстояние"}.

\vspace{\baselineskip}

Давайте вычислим значение «g» для синего квадрата, который находится слева от зеленого:

\vspace{\baselineskip}

\colorbox{gray!10!white}{ \parbox{12em}{abs(3 - 2) + abs(2 - 2) = 1}}

\vspace{\baselineskip}

Отлично! У нас есть значение: 1. Теперь давайте попробуем вычислить значение «h»:
\colorbox{gray!10!white}{ \parbox{12em}{abs(2 - 0) + abs(2 - 0) = 4}}

\vspace{\baselineskip}

Идеально. Теперь давайте получим значение "f": \colorbox{gray!10!white}{ \parbox{4em}{1 + 4 = 5}}

\vspace{\baselineskip}

Итак, окончательное значение для этого узла - «5».

\vspace{\baselineskip}

Давайте сделаем то же самое для оставшихся сРаздел 14.2. Алгоритм взвешенного планирования работ 
Алгоритм взвешенного планирования работ также может быть обозначен как алгоритм выбора взвешенной активности.

Задача заключается в том, чтобы определить максимальную прибыль, не выполняя две работы одновременно, при этом учитывая определенные задания и время начала и окончания их выполнения, а также прибыль, которую возможно получить после завершения работы.
иних кДавайте сделаем то же самое для оставшихся синих квадратов. Большое число в центре каждого квадрата - это значение «f», в верхнем левом углу -значение «g», а в  верхнем правом углу - значение «h»: вадратов. Большое число в центре каждого квадрата - это значение «f», в верхнем левом углу -значение «g», а в  верхнем правом углу - значение «h»:

\vspace{\baselineskip}

\includeimage{0.8}{images/66_1.pdf}

Мы вычислили значения g, h и f для всех синих узлов. Какой мы выбираем?

\vspace{\baselineskip}

Такой из них, который имеет наименьшее значение f. 

\vspace{\baselineskip}

Однако в этом случае у нас есть 2 узла с одинаковым значением f, равным 5. Как мы выбираем между ними? 

\vspace{\baselineskip}

Просто выберите случайным образом или установите приоритет. Я обычно предпочитаю ставить приоритет так: «справа> вверх> вниз> влево» 

\vspace{\baselineskip}

Один из узлов со значением f, равным 5, ведет нас «вниз», а другой - «влево». Так как вниз имеет более высокий приоритет, чем влево, мы выбираем квадрат, который приводит нас «вниз».

\vspace{\baselineskip}

Теперь я отмечаю узлы, для которых мы вычислили эвристику, но не переместили, как оранжевый, и узел, который мы выбрали, как голубой:

\vspace{\baselineskip}

\includeimage{0.8}{images/67_1.pdf}

Хорошо, теперь давайте вычислим ту же эвристику для узлов, которые расположены вокруг голубого узла:

\vspace{\baselineskip}

\includeimage{0.8}{images/67_2.pdf}

Опять же, мы выбираем узел, идущий вниз от голубого узла, так как все опции имеют одинаковое значение f:

\vspace{\baselineskip}

\includeimage{0.8}{images/68_1.pdf}

Давайте вычислим эвристику для единственного соседа, который имеет голубой узел: \

\vspace{\baselineskip}

\includeimage{0.8}{images/68_2.pdf}

Хорошо, мы будем следовать той же схеме, что и раньше:

\vspace{\baselineskip}

\includeimage{0.8}{images/69_1.pdf}

Давайте еще раз  вычислим эвристику для соседнего узла: 

\vspace{\baselineskip}

\includeimage{0.8}{images/69_2.pdf}

Давайте перейдем туда: 

\vspace{\baselineskip}

\includeimage{0.8}{images/70_1.pdf}

Наконец, мы видим, что у нас есть выигрышная клетка, и двигаемся туда.

\newpage
\chapter*{Глава 14: Динамическое программирование }
Динамическое программирование является широко используемой концепцией и часто используется для оптимизации. Оно относится к упрощению сложной проблемы путем ее рекурсивного разбиения на более простые подзадачи, обычно снизу вверх. Есть два ключевых атрибута, которые должны содержать задачи, чтобы динамическое программирование было применимо: «Оптимальная подструктура» и «Дублирование подзадач». Для достижения оптимизации в динамическом программировании используется концепция, называемая запоминанием.
\section*{Раздел 14.1: Расстояние Левенштейна}
Постановка задачи приближена к формулировке : если нам даны две строки str1 и str2, то какое минимальное количество операций может быть произведено над  str1, чтобы преобразовать ее в str2.

\vspace{\baselineskip}

\textbf{Реализация на Java}
\begin{tcolorbox}
\begin{minted}{java}
public class EditDistance {	
	// первая запускаемая функция
	public static void main(String[] args) {
		String str1 = "march";
		String str2 = "cart";
		EditDistance ed = new EditDistance();
		System.out.println(ed.getMinConversions(str1, str2));
	}
	// функция, возвращающая минимальное расстояние Левенштейна между двумя 
	// строками
	public int getMinConversions(String str1, String str2) {
		// dp[i][j] - минимальное расстояние Левенштейна между срезом первой 
		// строки до
		//i и срезом второй строки до j
		int dp[][] = new int[str1.length() + 1][str2.length() + 1];
		for (int i = 0; i <= str1.length(); i++) {
			for (int j = 0; j <= str2.length(); j++) {
				// если длина первой строки 0, тогда нам нужно скопировать все 
				//символы из второй строки (их j)
				if (i == 0) {
					dp[i][j] = j;
				}
				// если длина второй строки 0, тогда нам нужно скопировать все 
				//символы из первой строки (их i)
				else if (j == 0) {
					dp[i][j] = i;
				}
				// если последние символы двух строк совпадают, 
				//тогда общее кол-во операций не меняется
				else if (str1.charAt(i - 1) == str2.charAt(j - 1)) {
					dp[i][j] = dp[i - 1][j - 1];
				}
				// минимум из 3-х случаев: дописать/удалить символ к первому срезу,
				//ко второму и заменить последний символ одного среза на другой
				else {
					dp[i][j] = 1 + Math.min(dp[i - 1][j], Math.min(dp[i][j - 1], 
					dp[i - 1][j - 1]));
				}
			}
		}
		// ответ лежит в срезе первой строки до её длины, и срезе второй строки до 
		//её длины
		return dp[str1.length()][str2.length()];
	}
}
\end{minted}
\end{tcolorbox}
\textbf{Вывод:}

\vspace{\baselineskip}

3

\section*{Раздел 14.2: Алгоритм взвешенного планирования работ}

Алгоритм взвешенного планирования работ также может быть обозначен как алгоритм выбора взвешенной активности.

\vspace{\baselineskip}

Задача заключается в том, чтобы определить максимальную прибыль, не выполняя две работы одновременно, при этом учитывая определенные задания и время начала и окончания их выполнения, а также прибыль, которую возможно получить после завершения работы.


