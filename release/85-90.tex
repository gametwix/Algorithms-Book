% Ивенкова
\vspace{\baselineskip}
{\bfseries Код переменной длины} может работать гораздо лучше кода фиксированной длины. Частым символам присваиваются короткие кодовые слова, а нечастым символам --- длинные. Этот код требует $(45 \times 1 + 13 \times 3 + 12 \times 3 + 16 \times 3 + 9 \times 4 + 5 \times 4) \times 1000 = 224000$ бит для представления файла, что экономит приблизительно 25\% памяти.

\vspace{\baselineskip}
Следует помнить одно: мы рассматриваем здесь только те коды, в которых ни одно кодовое слово не является началом (префиксом) другого. Такие коды называются {\itshape префиксными}. Для кодирования с переменной длиной мы кодируем 3-символьный файл {\itshape abc} как 0.101.100 = 0101100, где “.” означает конкатенацию.

\vspace{\baselineskip}
Желательно использовать префиксные коды, поскольку они упрощают декодирование. Так как ни одно кодовое слово не является префиксом другого, то кодовое слово, с которого начинается файл, декодируется однозначно. Мы можем легко идентифицировать исходное кодовое слово, декодировать его и повторить этот процесс на оставшейся части закодированного файла. Например, 001011101 однозначно представляется как 0.0.101.1101, что декодируется как {\itshape aabe}. Короче говоря, все комбинации двоичных представлений уникальны. Например, если одна буква обозначается как 110, то никакая другая буква не может обозначаться как 1101 или 1100. Это сделано для того, чтобы у вас не было неопределенности: выбрать 110 или продолжить конкатенацию следующих битов и выбрать более длинное кодовое слово.

\vspace{\baselineskip}
{\bfseries Техника сжатия}

\vspace{\baselineskip}
Эта техника работает путем создания двоичного дерева узлов. Они могут храниться в обычном массиве, размер которого зависит от количества символов {\bfseries n}. Узел может быть или {\itshape листовым}, или {\itshape внутренним}. Изначально все узлы --- листья и содержат сам символ, его частоту и, возможно, ссылку на его сыновей. Как правило, битом ‘0’ обозначают левого сына, а ‘1’ --- правого. Для хранения узлов используется очередь с {\itshape приоритетом}, где на первом месте находится узел с наименьшей частотой. Этот процесс описан ниже:

\begin{enumerate} 
  \item Создайте узел для каждого символа и добавьте его в очередь с приоритетом.
  \item Пока в очереди хранится более одного узла:
    \begin{enumerate} 
        \item[1.] Удалите из очереди два узла с наибольшим приоритетом.
        \item[2.] Создайте новый внутренний узел с этими двумя узлами в качестве сыновей и с частотой, равной сумме частот этих двух узлов.
        \item[3.] Добавьте новый узел в очередь.
    \end{enumerate} 
  \item Оставшийся узел будет корнем. Дерево Хаффмана построено.
\end{enumerate}

Для нашего примера:
%\enlargethispage{-13\baselineskip}

%\newpage
\includeimage{0.57}{images/86.pdf}

Псевдокод выглядит так:

\vspace{\baselineskip}
\begin{tcolorbox}
\begin{minted}{python}
# C - это набор из n символов и соответствующей информации #
Procedure Huffman(C):
	n = C.size
	Q = priority_queue()
	for i = 1 to n
		n = node(C[i])
		Q.push(n)
	end for
	# пока размер информации не равен 1
	while Q.size() is not equal to 1
		# создаем новый внутренний узел 
	Z = new node()
	# устанавливаем узлы в качестве потомков
	Z.left = x = Q.pop
	Z.right = y = Q.pop
	# частота, равная сумме частот двух узлов
	Z.frequency = x.frequency + y.frequency
	Q.push(Z)
end while
Return Q
\end{minted}
\end{tcolorbox}

\vspace{\baselineskip}
В общем случае для использования этого алгоритма требуется предварительная сортировка. Поскольку сортировка в общем случае занимает {\bfseries O(n*log(n))} времени, оба метода имеют одинаковую сложность.

\vspace{\baselineskip}
Поскольку {\bfseries n} здесь --- это число символов в алфавите, которое обычно очень мало (по сравнению с длиной закодированного сообщения), временная сложность не особо важна при выборе алгоритма.

\vspace{\baselineskip}
{\bfseries Техника декомпрессии:}

\vspace{\baselineskip}
Процесс декомпрессии --- это просто перевод потока префиксных кодов в отдельное байтовое значение, обычно, путем обхода дерева Хаффмана по мере считывания каждого бита из входного потока. Достижение листового узла обязательно завершает поиск конкретного значения байта. Значение листа представляет собой требуемый символ. Обычно дерево Хаффмана строится с использованием статистически скорректированных данных по каждому циклу компрессии, поэтому реконструкция довольно проста. В противном случае информация для восстановления дерева должна быть отправлена отдельно. Псевдокод:

\vspace{\baselineskip}
\begin{tcolorbox}
\begin{minted}{python}
Procedure HuffmanDecompression(root, S): 
# root - представляет корень дерева Хаффмана S относится к потоку битов, 
# который нужно распаковать 
n := S.length 
for i := 1 to n
	current = root
	# пока не спустились по дереву
	while current.left != NULL and current.right != NULL
		# переход влево, если попадается 0, иначе - вправо
		if S[i] is equal to '0'
			current := current.left
		else
			current := current.right
		endif
		# следующий символ, перехватываем индекс i
		i := i+1
	endwhile
	# индекс i снова перебирается другим циклом
	print current.symbol
endfor
\end{minted}
\end{tcolorbox}

\vspace{\baselineskip}
{\bfseries Объяснение жадности алгоритма:}
Кодирование Хаффмана рассматривает вхождение каждого символа и сохраняет его в виде двоичной строки оптимальным образом. Идея состоит в том, чтобы присваивать входным символам коды переменной длины, длина присваиваемых кодов основана на частоте соответствующих символов. Мы создаем двоичное дерево и работам с ним “снизу вверх” так, чтобы как минимум два часто встречающихся символа были как можно дальше от корня. Таким образом, самый частый символ получает наименьший код, а наименее частый --- наибольший.

\vspace{\baselineskip}
{\bfseries Рекомендации:}

\begin{itemize}
  \item Алгоритмы. Построение и анализ --- Чарльз Лейзерсон, Клиффорд Штайн, Рональд Ривест, и Томас Кормен
  \item \href{https://en.wikipedia.org/wiki/Huffman_coding}{\underline{Код Хаффмана}} --- Википедия 
  \item Discrete Mathematics and Its Applications --- Кеннет Розен
\end{itemize}

\section*{Раздел 17.2: Проблема выбора вида деятельности}

\vspace{\baselineskip}
{\bfseries Проблема}

\vspace{\baselineskip}
У вас есть набор задач, которые нужно выполнить. Каждое задание имеет время начала и время окончания. Вам не разрешается выполнять более одной задачи за раз. Ваша задача --- найти способ выполнить максимальное количество заданий.

\vspace{\baselineskip}
Например, предположим, что вам нужно выбрать уроки из списка.

\vspace{\baselineskip}
%\tcbset{colback=gray!10!white, enhanced jigsaw, breakable, boxrule=0mm, arc=3mm, top=2mm, left=1.5mm, bottom=1mm} % параметры серого прямоугольника
\begin{tcolorbox}[width=9cm,enhanced,colback=white,colframe=white,colbacktitle=white,tabulars={@{\extracolsep{\fill}\hspace{0mm}}lrrrrr@{\hspace{5mm}}}]
\bfseries № задачи & \bfseries Начало & \bfseries Конец \\\hline

1 & 10.20   A.M. &	11.00 A.M.\\\hline

2 &	10.30	A.M. &	11.30 A.M.\\\hline

3 & 11.00	A.M. &	12.00 A.M.\\\hline

4 & 10.00	A.M. &	11.30 A.M.\\\hline

5 & 9.00    A.M. &	11.00 A.M.\\\hline
\end{tcolorbox}

Помните, что вы не можете присутствовать на двух занятиях одновременно. Это означает, что вы не можете выбрать уроки 1 и 2, потому что у них общее время с 10:30 до 11:00. Однако, вы можете выбрать занятия 1 и 3, потому что они проходят в разное время. Итак, ваша задача состоит в том, чтобы выбрать максимально возможное число уроков без накладок. Как вы можете это сделать?

\vspace{\baselineskip}
{\bfseries Анализ}

\vspace{\baselineskip}
Давайте подумаем над решением с помощью жадного подхода. Прежде всего мы случайным образом выбираем какой-нибудь подход и проверяем, сработает он или нет.

\begin{itemize}
  \item {\bfseries Сортировка задач по времени начала.} Это означает, что задания, которые начинаются раньше всего, мы будем выполнять в первую очередь. Затем будем перебирать задачи по порядку и проверять, будут ли они пересекаться по времени с предыдущим выбранным заданием или нет. Если текущая работа не пересекается с ранее выбранной, то мы будем ее выполнять, а в противном случае не будем. Этот подход сработает для некоторых случаев. Например:
\end{itemize}

\begin{tcolorbox}[width=9cm,enhanced,colback=white,colframe=white,colbacktitle=white,tabulars={@{\extracolsep{\fill}\hspace{0mm}}lrrrrr@{\hspace{5mm}}}]
\bfseries № задачи & \bfseries Начало & \bfseries Конец \\\hline

1 & 11.00	 A.M. &	1.30 P.M.\\\hline

2 &	11.30	A.M. &	12.00 P.M.\\\hline

3 & 1.30	P.M. &	2.00 P.M.\\\hline

4 & 10.00	A.M. &	11.00 A.M.\\\hline
\end{tcolorbox}

Порядок сортировки будет 4 -$ $-> 1 -$ $-> 2 -$ $-> 3 и только четвертая задача будет выполнена, но ответом может быть последовательность действий 1 -$ $-> 3 или 2 -$ $-> 3, которые могут быть выполнены. Таким образом, наш подход не будет работать в приведенном выше случае. Давайте попробуем другой подход.

\begin{itemize}
  \item {\bfseries Сортировка задач по длительности.} То есть сначала выполняются наименее длительные действия. Это поможет решить предыдущую проблему. Однако сама проблема в целом до конца не решена. Есть еще несколько случаев, в которых такой подход не сработает. Применим этот подход к следующему случаю.
\end{itemize}

\begin{tcolorbox}[width=9cm,enhanced,colback=white,colframe=white,colbacktitle=white,tabulars={@{\extracolsep{\fill}\hspace{0mm}}lrrrrr@{\hspace{5mm}}}]
\bfseries № задачи & \bfseries Начало & \bfseries Конец \\\hline

1 & 6.00   A.M. &	11.40 A.M.\\\hline

2 &	11.30	A.M. &	12.00 P.M.\\\hline

3 & 11.40	A.M. &	2.00 P.M.\\\hline
\end{tcolorbox}

Если мы отсортируем задания по длительности их выполнения, то получим порядок 2-->3-->1. И если мы сначала выполним задачу 2, то больше ничего мы выполнить не сможем. Но ответом будет выполнение задачи 1, а затем задачи 3. Таким образом, мы можем выполнить максимум два задания. Так что такой подход не может быть решением данной проблемы. Нам нужно искать другой.

\vspace{\baselineskip}
{\bfseries Анализ}
\begin{itemize}
  \item {\bfseries Сортировка задач по времени их окончания.} Это означает, что та задача, которая заканчивается раньше, располагается первее. Алгоритм приведен ниже.
\end{itemize}

\vspace{-8mm}
\pline{0.6}{
\begin{enumerate} 
    \item[ ] \vspace{3mm}
    \item Отсортируйте задания по времени их окончания.
    \item Если задача по времени не пересекается с ранее выполненными, то выполните ее.
    \item[] \vspace{3mm}
\end{enumerate}
}
\vspace{-8mm}

\vspace{\baselineskip}
Давайте проанализируем первый пример

\vspace{\baselineskip}
\begin{tcolorbox}[width=9cm,enhanced,colback=white,colframe=white,colbacktitle=white,tabulars={@{\extracolsep{\fill}\hspace{0mm}}lrrrrr@{\hspace{5mm}}}]
\bfseries № задачи & \bfseries Начало & \bfseries Конец \\\hline

1 & 10.20   A.M. &	11.00 A.M.\\\hline

2 &	10.30	A.M. &	11.30 A.M.\\\hline

3 & 11.00	A.M. &	12.00 A.M.\\\hline

4 & 10.00	A.M. &	11.30 A.M.\\\hline

5 & 9.00    A.M. &	11.00 A.M.\\\hline
\end{tcolorbox}

Отсортируем задачи по времени их окончания. Итак, порядок сортировки 1 -$ $-> 5 -$ $-> 2 -$ $-> 4 -$ $-> 3. Ответ 1 -$ $-> 3 --- эти две задачи будут выполнены. И это действительно правильный ответ. Вот алгоритм для построения кода:


\pline{2.4}{
\begin{enumerate} 
    \item[ ] \vspace{3mm}
    \item Сортировать: задачи
    \item Выполнить первую задачу из отсортированного списка
    \item Текущая задача := первая задача
    \item Время окончания := время окончания текущей задачи
    \item Перейти к следующей задаче, если она существует. Иначе завершить работу
    \item Если время начала текущей задачи <= Время окончания : выполнить задачу и перейти к п. 4
    \item Иначе : перейти к п. 5
    \item[ ] \vspace{3mm}
    \end{enumerate}
}

помощь с кодом: \href{https://www.geeksforgeeks.org/activity-selection-problem-greedy-algo-1/}{\underline{http://www.geeksforgeeks.org/greedy-algorithms-set-1-activity-selection-problem/}}

\section*{Раздел 17.3:  Проблема выдачи сдачи}

\vspace{\baselineskip}
При данной денежной системе, можно ли выдать определенную сумму денег и как найти минимальный набор монет, соответствующий заданной сумме?

\vspace{\baselineskip}
{\bfseries Канонические денежные системы.} Для некоторых денежных систем, таких как те, которые мы используем в реальной жизни, “интуитивное” решение работает идеально. Например, если имеются монеты и банкноты номиналом в 1\euro, 2\euro, 5\euro, 10\euro, то, выдавая самую крупную монету или купюру, пока не дойдем до нужной суммы, и повторяя данную процедуру, мы получим минимальный набор монет.

\vspace{\baselineskip}
Мы можем сделать это рекурсивно на языке OCaml:

\vspace{\baselineskip}
\begin{tcolorbox}
\begin{minted}{OCaml}
(* при условии, что денежная система отсортирована в порядке убывания *)
let change_make money_system amount =
	(* устанавливает сдачу после пересчета *)
	let rec loop given amount =
		if amount = 0 then 
			given
		else
			(* мы находим первое значение, которое меньше или равно
			оставшемуся количеству *)
			let coin = List.find ((>=) amount) money_system in
			loop (coin::given) (amount - coin)
  in loop [] amount
\end{minted}
\end{tcolorbox}

\vspace{\baselineskip}
Такие системы сделаны так, что набрать сдачу легко. Проблема усложняется, когда речь заходит о произвольных денежных системах.

\vspace{\baselineskip}
{\bfseries Общий случай.} Как выдать 99\euro, имея монеты номиналом 10\euro, 7\euro и 5\euro? Здесь выдача монет по 10\euro до тех пор, пока не останется выдать 9\euro, очевидно, не приводит ни к какому решению. Хуже того, решение может и не существовать. На самом деле данная задача является NP-трудной, но существуют приемлемые решения, основанные на {\bfseries жадных алгоритмах} и {\bfseries мемоизации}. Идея состоит в том, чтобы исследовать все возможные варианты и выбрать тот, в котором имеется минимальное количество монет.

\vspace{\baselineskip}
Чтобы выдать сумму X > 0, мы выбираем произвольное P, а затем решаем подзадачу для выдачи суммы X - P. Мы попробуем сделать это для всех возможных P. Решение, если оно существует, является наименьшим путем, который привел нас к 0.

\vspace{\baselineskip}
Вот рекурсивная функция, соответствующая данному методу, написанная на OCaml. Если решения не существует, то она возвращает None.

\vspace{\baselineskip}
\begin{tcolorbox}
\begin{minted}{OCaml}
(* вариант утилиты *)
let optmin x y =
	(* если в паре есть один элемент None, то получить соседнее значение *)
	match x, y with
	| None, a | a, None -> a
	| Some x, Some y -> Some (min x y)

(* инкремент входного аргумента, за исключением None *)
let optsucc = function
	| Some x -> Some (x+1)
	| None -> None

(* Проблема изменения *)
let change_make money_system amount =
	let rec loop n =
		let onepiece acc piece =
			(* если разница долга и сдачи равна 0, то *)
			match n - piece with
			| 0 -> (* проблема решена одной монетой *)
				Some 1
			| x -> if x < 0 then
				(* если не достигаем 0, то отбрасываем это решение *)
				None
			else
				(* ищем наименьший путь, отличный от None с остальными частями *)
				optmin (optsucc (loop x)) acc
	in
	(* называем onepiece для всех частей *)
	List.fold_left onepiece None money_system
in loop amount
\end{minted}
\end{tcolorbox}

\vspace{\baselineskip}
{\bfseries Примечание:} можно заметить, что эта процедура может вычислять набор монет для одного и того же значения несколько раз. На практике, чтобы избежать таких повторений, используется техника мемоизации. Использование такой техники приводит к более быстрому (намного более быстрому) результату.

