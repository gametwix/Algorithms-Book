%Велесов

\chapter*{Глава 22: Алгоритм Флойда- Уоршелла}
\section*{Раздел 22.1. Алгоритм кратчайшего пути для всех пар}

\vspace{\baselineskip}
Алгоритм Флойда-Уоршелла предназначен для поиска кратчайших путей во взвешенном графе с положительным или отрицательными весом ребер. Однократное выполнение алгоритма найдет длины (суммарные веса) кратчайших путей между всеми парами вершин. С небольшими вариациями он может распечатать кратчайший путь и обнаружить отрицательные циклы на графике. Флойд-Уоршелл - это алгоритм динамического программирования.

Давайте посмотрим на пример. Мы собираемся применить алгоритм Флойда-Уоршелла на этом графике:

\vspace{\baselineskip}
\includeimage{0.648}{images/129_1.pdf}
\vspace{\baselineskip}

\vspace{\baselineskip}
Для начала возьмем 2 2D матрицы. Это матрицы смежности. Размер матриц будет общим числом вершин. Для нашего графа мы возьмем матрицы \textbf{4 * 4}. \textbf{Матрица расстояний} будет хранить минимальное расстояние, найденное между двумя вершинами в настоящее время. Во-первых, для ребер, если есть ребро между \textbf{u-v} и \textbf{w} является расстоянием, мы будем хранить: \textbf{distance[u][v]} = \textbf{w}. Для всех ребер, которые не существуют, мы ставим \textit{бесконечность}. \textbf{Матрица путей} предназначена для восстановления пути минимального расстояния между двумя вершинами. Итак, изначально, если есть путь между \textbf{u} и \textbf{v}, мы будем класть \textbf{path[u][v]} = \textbf{u}. Это означает, что лучший способ добраться до \textbf{вершины-v} из \textbf{вершины-u} - это использовать ребро, соединяющее \textbf{v} с \textbf{u}. Если между двумя вершинами пути нет, мы добавим туда \textbf{N}, указывая, что пути сейчас нет. Две таблицы для нашего графика будут выглядеть так:

\newpage

\begin{tcolorbox}
\begin{verbatim}
+-----+-----+-----+-----+-----+  +-----+-----+-----+-----+-----+
|     | 1   | 2   | 3   | 4   |  |     |  1  |   2 |   3 |   4 |
+-----+-----+-----+-----+-----+  +-----+-----+-----+-----+-----+
| 1   |  0  |  3  |  6  | 15  |  |  1  |  N  |  1  |  1  |  1  |
+-----+-----+-----+-----+-----+  +-----+-----+-----+-----+-----+
| 2   | inf |   0 |  -2 | inf |  |  2  |  N  |   N |   2 |  N  |
+-----+-----+-----+-----+-----+  +-----+-----+-----+-----+-----+
| 3   | inf | inf |  0  |  2  |  |  3  |  N  |  N  |  N  |  3  |
+-----+-----+-----+-----+-----+  +-----+-----+-----+-----+-----+
| 4   |  1  | inf | inf |  0  |  |  4  |   4 |   N |  N  |  N  |
+-----+-----+-----+-----+-----+  +-----+-----+-----+-----+-----+
distance                         path

\end{verbatim}
\end{tcolorbox}

Поскольку петли нет, диагонали установлены на \textbf{N}. Расстояние от самой вершины равно \textbf{0}.

Чтобы применить алгоритм Флойда-Уоршелла, мы выберем среднюю вершину \textbf{k}. Затем для каждой вершины \textbf{i}мы собираемся проверить, можем ли мы перейти от \textbf{i} к \textbf{k}, а затем от  \textbf{k} к \textbf{j}, где \textbf{j} - другая вершина, и минимизировать стоимость перехода от \textbf{i} к \textbf{j}. Если текущее \textbf{distance[i][j]} больше, чем \textbf{distance[i][k]} + \textbf{distance[k][j]}, мы сделаем \textbf{distance[i][j]} равным сумме этих двух расстояний. И \textbf{path[i][j]} будет присвоено \textbf{path[k][j]}, как лучше перейти от \textbf{i} к \textbf{k},

%\newpage

\vspace{\baselineskip}
а затем от \textbf{k} к \textbf{j}. Все вершины будут выбраны как \textbf{k}. У нас будет 3 вложенных цикла: для \textbf{k} - от 1 до 4, для \textbf{i} - от 1 до 4, а для \textbf{j} - от 1 до 4. Мы собираемся проверить:

\vspace{\baselineskip}
\begin{minted}{Pascal}
if distance[i][j] > distance[i][k] + distance[k][j]
distance[i][j] := distance[i][k] + distance[k][j]
path[i][j] := path[k][j]
end if
\end{minted}

\vspace{\baselineskip}
Ну что ж, в основном мы проверяем, \textit{получаем ли для каждой пары вершин более короткое расстояние, проходя через другую вершину?} Общее количество операций для нашего графа будет \textbf{4 * 4 * 4 = 64}. Это означает, что мы собираемся сделать эту проверку \textbf{64} раза. Когда \textbf{k = 1}, \textbf{i = 2} и \textbf{j = 3}, \textbf{distance[i][j]} равно \textbf{-2}, которое не больше чем \textbf{distance[i][k]} + \textbf{distance[k][j]} = \textbf{-2} + \textbf{0} = \textbf{-2}. Так что это останется без изменений.  Опять же когда \textbf{k = 1}, \textbf{i = 4} и \textbf{j = 2}, \textbf{distance[i][j]} = \textbf{infinity}, которое больше чем \textbf{distance[i][k]} + \textbf{distance[k][j]} = \textbf{1} + \textbf{3}=\textbf{4}. Итак, мы ставим \textbf{distance[i][j]} = \textbf{4}, и мы положили \textbf{path[i][j]} = \textbf{path[k][j]} = \textbf{1}. Это означает, что для перехода от \textbf{вершины-4} к \textbf{вершине-2} путь \textbf{4-> 1-> 2} короче существующего пути. Так мы заполняем обе матрицы. Расчет для каждого шага показан здесь. После внесения необходимых изменений наши матрицы будут выглядеть так:

\newpage

\begin{tcolorbox}
\begin{verbatim}
+-----+-----+-----+-----+-----+  +-----+-----+-----+-----+-----+
|     | 1   | 2   | 3   | 4   |  |     |  1  |   2 |   3 |   4 |
+-----+-----+-----+-----+-----+  +-----+-----+-----+-----+-----+
| 1   |  0  |  3  |  1  | 3   |  |  1  |  N  |  1  |  2  |  3  |
+-----+-----+-----+-----+-----+  +-----+-----+-----+-----+-----+
| 2   |  1  |   0 |  -2 |  0  |  |  2  |  4  |   N |   2 |  3  |
+-----+-----+-----+-----+-----+  +-----+-----+-----+-----+-----+
| 3   | 3   | 6   |  0  |  2  |  |  3  |  4  |  1  |  N  |  3  |
+-----+-----+-----+-----+-----+  +-----+-----+-----+-----+-----+
| 4   |  1  | 4   | 2   |  0  |  |  4  |   4 |  1  |  2  |  N  |
+-----+-----+-----+-----+-----+  +-----+-----+-----+-----+-----+
distance                         path
\end{verbatim}
\end{tcolorbox}

\vspace{\baselineskip}
Это наша матрица кратчайшего расстояния. Например, самое короткое расстояние от \textbf{1} до \textbf{4} равно \textbf{3}, а самое короткое расстояние от \textbf{4} до \textbf{3} - \textbf{2}. Наш псевдокод будет:

\vspace{\baselineskip}
\begin{minted}{Pascal}
Procedure Floyd-Warshall(Graph):
for k from 1 to V // V denotes the number of vertex
	for i from 1 to V
		for j from 1 to V
			if distance[i][j] > distance[i][k] + distance[k][j]
				distance[i][j] := distance[i][k] + distance[k][j]
				path[i][j] := path[k][j]
			end if
			end for
	end for
end for
\end{minted}


\vspace{\baselineskip}
\textbf{Печать пути:}

\vspace{\baselineskip}
Чтобы напечатать путь, мы проверим матрицу \textbf{пути}. Чтобы напечатать путь от \textbf{u} до \textbf{v}, мы \textbf{path[u][v]}. Мы будем продолжать изменять \textbf{v} = \textbf{path[u][v]}, пока не найдем \textbf{path[u][v]} = \textbf{u} и не поместим все значения \textbf{path[u][v]} в стек. Найдя \textbf{u}, мы распечатаем \textbf{u} и начнем вытаскивать элементы из стопки и распечатывать их. Это работает, потому что матрица путей хранит значение вершины, которая разделяет кратчайший путь к \textbf{v} от любого другого узла. Псевдокод будет:

\vspace{\baselineskip}

\begin{minted}{python}
Procedure PrintPath(source, destination):
s = Stack()
S.push(destination)
while Path[source][destination] is not equal to source
S.push(Path[source][destination])
destination := Path[source][destination]
end while
print -> source
while S is not empty
print -> S.pop
end while
\end{minted}

%\newpage

\vspace{\baselineskip}
\textbf{Нахождение отрицательного цикла в графе:}

\vspace{\baselineskip}
Чтобы выяснить, существует ли отрицательный  цикл в графе, нам нужно проверить основную диагональ матрицы \textbf{расстояний}. Если какое-либо значение на диагонали отрицательно, это означает, что в графе  есть отрицательный цикл.

\vspace{\baselineskip}
\textbf{Сложность:}
\vspace{\baselineskip}

Сложность алгоритма Флойда-Уоршелла составляет \textbf{O (V³)}, а сложность пространства: \textbf{O (V²)}.

%\newpage

\chapter*{Глава 23: Числа Каталана}
\section*{Раздел 23.1: Числа Каталана. Основная информация}
\vspace{\baselineskip}
Алгоритм каталонских чисел - это алгоритм динамического программирования.

В комбинаторной математике каталонские числа образуют последовательность натуральных чисел, которые встречаются в различных задачах счета, часто связанных с участием рекурсивно определенных объектов. Каталонские числа на неотрицательных целых числах n представляют собой набор чисел, возникающих в задачах перечисления деревьев типа: «Сколькими способами можно разделить регулярный n-угольник на n-2 треугольника, если разные ориентации учитываются отдельно?»

\vspace{\baselineskip}
\textbf{Применение алгоритма каталонского числа:}
\begin{itemize}
\itemКоличество способов сложить монеты в нижнем ряду, который состоит из n последовательно лежащих монет в плоскости, так что монеты не могут быть размещены на двух сторонах нижних монет, и каждая дополнительная монета должна быть выше двух других монет, составляет n-ный каталонский номер.

\itemЧисло способов сгруппировать строку из n пар круглых скобок, чтобы каждая открытая скобка имела совпадающую закрытую скобку, является n-м каталонским числом.

\itemЧисло способов разрезать n + 2-сторонний выпуклый многоугольник на плоскости на треугольники, соединяя вершины прямыми не пересекающимися линиями, является n-м каталонским числом. Это применения, которым интересовался Эйлер.
\end{itemize}

Используя нумерацию с нуля, n-е каталонское число дается непосредственно в терминах биномиальных коэффициентов следующим уравнением.

\vspace{\baselineskip}
\begin{tcolorbox}

$$C_{n}=\frac{1}{n+1} \left(\begin{array}{crl}
2n\\
n\end{array}\right)=\frac{(2n)!}{(n+1)!n!} = \Pi^{n}_{k=2} \frac{n+k}{k} ~~~~ n \geq 0$$

\end{tcolorbox}

\vspace{\baselineskip}
\textbf{Пример каталонского номера:}
\vspace{\baselineskip}
Здесь значение n = 4. (Лучший пример - из Википедии)

\vspace{\baselineskip}
\includeimage{0.6}{images/132-1.pdf}

\vspace{\baselineskip}

\textbf{Вспомогательное пространство}: $O(n)$

\textbf{Сложность по времени}: $O(n^2)$

